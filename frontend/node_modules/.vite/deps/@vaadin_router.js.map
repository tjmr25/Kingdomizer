{
  "version": 3,
  "sources": ["../../path-to-regexp/src/index.ts", "../../@vaadin/router/src/resolver/utils.ts", "../../@vaadin/router/src/resolver/matchPath.ts", "../../@vaadin/router/src/resolver/matchRoute.ts", "../../@vaadin/router/src/resolver/resolveRoute.ts", "../../@vaadin/router/src/resolver/resolver.ts", "../../@vaadin/router/src/resolver/generateUrls.ts", "../../@vaadin/vaadin-development-mode-detector/vaadin-development-mode-detector.js", "../../@vaadin/vaadin-usage-statistics/vaadin-usage-statistics-collect.js", "../../@vaadin/router/scripts/register.js", "../../@vaadin/router/src/router-meta.ts", "../../@vaadin/router/src/transitions/animate.ts", "../../@vaadin/router/src/utils.ts", "../../@vaadin/router/src/triggers/click.ts", "../../@vaadin/router/src/triggers/popstate.ts", "../../@vaadin/router/src/triggers/navigation.ts", "../../@vaadin/router/src/router.ts"],
  "sourcesContent": ["/**\n * Tokenizer results.\n */\ninterface LexToken {\n  type:\n    | \"OPEN\"\n    | \"CLOSE\"\n    | \"PATTERN\"\n    | \"NAME\"\n    | \"CHAR\"\n    | \"ESCAPED_CHAR\"\n    | \"MODIFIER\"\n    | \"END\";\n  index: number;\n  value: string;\n}\n\n/**\n * Tokenize input string.\n */\nfunction lexer(str: string): LexToken[] {\n  const tokens: LexToken[] = [];\n  let i = 0;\n\n  while (i < str.length) {\n    const char = str[i];\n\n    if (char === \"*\" || char === \"+\" || char === \"?\") {\n      tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"\\\\\") {\n      tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"{\") {\n      tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"}\") {\n      tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \":\") {\n      let name = \"\";\n      let j = i + 1;\n\n      while (j < str.length) {\n        const code = str.charCodeAt(j);\n\n        if (\n          // `0-9`\n          (code >= 48 && code <= 57) ||\n          // `A-Z`\n          (code >= 65 && code <= 90) ||\n          // `a-z`\n          (code >= 97 && code <= 122) ||\n          // `_`\n          code === 95\n        ) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) throw new TypeError(`Missing parameter name at ${i}`);\n\n      tokens.push({ type: \"NAME\", index: i, value: name });\n      i = j;\n      continue;\n    }\n\n    if (char === \"(\") {\n      let count = 1;\n      let pattern = \"\";\n      let j = i + 1;\n\n      if (str[j] === \"?\") {\n        throw new TypeError(`Pattern cannot start with \"?\" at ${j}`);\n      }\n\n      while (j < str.length) {\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === \")\") {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n          if (str[j + 1] !== \"?\") {\n            throw new TypeError(`Capturing groups are not allowed at ${j}`);\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (count) throw new TypeError(`Unbalanced pattern at ${i}`);\n      if (!pattern) throw new TypeError(`Missing pattern at ${i}`);\n\n      tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n      i = j;\n      continue;\n    }\n\n    tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n  }\n\n  tokens.push({ type: \"END\", index: i, value: \"\" });\n\n  return tokens;\n}\n\nexport interface ParseOptions {\n  /**\n   * Set the default delimiter for repeat parameters. (default: `'/'`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters to automatically consider prefixes when parsing.\n   */\n  prefixes?: string;\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str: string, options: ParseOptions = {}): Token[] {\n  const tokens = lexer(str);\n  const { prefixes = \"./\", delimiter = \"/#?\" } = options;\n  const result: Token[] = [];\n  let key = 0;\n  let i = 0;\n  let path = \"\";\n\n  const tryConsume = (type: LexToken[\"type\"]): string | undefined => {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n\n  const mustConsume = (type: LexToken[\"type\"]): string => {\n    const value = tryConsume(type);\n    if (value !== undefined) return value;\n    const { type: nextType, index } = tokens[i];\n    throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\n  };\n\n  const consumeText = (): string => {\n    let result = \"\";\n    let value: string | undefined;\n    while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n      result += value;\n    }\n    return result;\n  };\n\n  const isSafe = (value: string): boolean => {\n    for (const char of delimiter) if (value.indexOf(char) > -1) return true;\n    return false;\n  };\n\n  const safePattern = (prefix: string) => {\n    const prev = result[result.length - 1];\n    const prevText = prefix || (prev && typeof prev === \"string\" ? prev : \"\");\n\n    if (prev && !prevText) {\n      throw new TypeError(\n        `Must have text between two parameters, missing text after \"${(prev as Key).name}\"`,\n      );\n    }\n\n    if (!prevText || isSafe(prevText)) return `[^${escapeString(delimiter)}]+?`;\n    return `(?:(?!${escapeString(prevText)})[^${escapeString(delimiter)}])+?`;\n  };\n\n  while (i < tokens.length) {\n    const char = tryConsume(\"CHAR\");\n    const name = tryConsume(\"NAME\");\n    const pattern = tryConsume(\"PATTERN\");\n\n    if (name || pattern) {\n      let prefix = char || \"\";\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n\n      if (path) {\n        result.push(path);\n        path = \"\";\n      }\n\n      result.push({\n        name: name || key++,\n        prefix,\n        suffix: \"\",\n        pattern: pattern || safePattern(prefix),\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    const value = char || tryConsume(\"ESCAPED_CHAR\");\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    if (path) {\n      result.push(path);\n      path = \"\";\n    }\n\n    const open = tryConsume(\"OPEN\");\n    if (open) {\n      const prefix = consumeText();\n      const name = tryConsume(\"NAME\") || \"\";\n      const pattern = tryConsume(\"PATTERN\") || \"\";\n      const suffix = consumeText();\n\n      mustConsume(\"CLOSE\");\n\n      result.push({\n        name: name || (pattern ? key++ : \"\"),\n        pattern: name && !pattern ? safePattern(prefix) : pattern,\n        prefix,\n        suffix,\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    mustConsume(\"END\");\n  }\n\n  return result;\n}\n\nexport interface TokensToFunctionOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Function for encoding input strings for output.\n   */\n  encode?: (value: string, token: Key) => string;\n  /**\n   * When `false` the function can produce an invalid (unmatched) path. (default: `true`)\n   */\n  validate?: boolean;\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile<P extends object = object>(\n  str: string,\n  options?: ParseOptions & TokensToFunctionOptions,\n) {\n  return tokensToFunction<P>(parse(str, options), options);\n}\n\nexport type PathFunction<P extends object = object> = (data?: P) => string;\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction<P extends object = object>(\n  tokens: Token[],\n  options: TokensToFunctionOptions = {},\n): PathFunction<P> {\n  const reFlags = flags(options);\n  const { encode = (x: string) => x, validate = true } = options;\n\n  // Compile all the tokens into regexps.\n  const matches = tokens.map((token) => {\n    if (typeof token === \"object\") {\n      return new RegExp(`^(?:${token.pattern})$`, reFlags);\n    }\n  });\n\n  return (data: Record<string, any> | null | undefined) => {\n    let path = \"\";\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n\n      const value = data ? data[token.name] : undefined;\n      const optional = token.modifier === \"?\" || token.modifier === \"*\";\n      const repeat = token.modifier === \"*\" || token.modifier === \"+\";\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to not repeat, but got an array`,\n          );\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n\n          throw new TypeError(`Expected \"${token.name}\" to not be empty`);\n        }\n\n        for (let j = 0; j < value.length; j++) {\n          const segment = encode(value[j], token);\n\n          if (validate && !(matches[i] as RegExp).test(segment)) {\n            throw new TypeError(\n              `Expected all \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`,\n            );\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\") {\n        const segment = encode(String(value), token);\n\n        if (validate && !(matches[i] as RegExp).test(segment)) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`,\n          );\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n\n      const typeOfMessage = repeat ? \"an array\" : \"a string\";\n      throw new TypeError(`Expected \"${token.name}\" to be ${typeOfMessage}`);\n    }\n\n    return path;\n  };\n}\n\nexport interface RegexpToFunctionOptions {\n  /**\n   * Function for decoding strings for params.\n   */\n  decode?: (value: string, token: Key) => string;\n}\n\n/**\n * A match result contains data about the path match.\n */\nexport interface MatchResult<P extends object = object> {\n  path: string;\n  index: number;\n  params: P;\n}\n\n/**\n * A match is either `false` (no match) or a match result.\n */\nexport type Match<P extends object = object> = false | MatchResult<P>;\n\n/**\n * The match function takes a string and returns whether it matched the path.\n */\nexport type MatchFunction<P extends object = object> = (\n  path: string,\n) => Match<P>;\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match<P extends object = object>(\n  str: Path,\n  options?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions,\n) {\n  const keys: Key[] = [];\n  const re = pathToRegexp(str, keys, options);\n  return regexpToFunction<P>(re, keys, options);\n}\n\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction<P extends object = object>(\n  re: RegExp,\n  keys: Key[],\n  options: RegexpToFunctionOptions = {},\n): MatchFunction<P> {\n  const { decode = (x: string) => x } = options;\n\n  return function (pathname: string) {\n    const m = re.exec(pathname);\n    if (!m) return false;\n\n    const { 0: path, index } = m;\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n\n      if (key.modifier === \"*\" || key.modifier === \"+\") {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map((value) => {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    }\n\n    return { path, index, params };\n  };\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str: string) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options?: { sensitive?: boolean }) {\n  return options && options.sensitive ? \"\" : \"i\";\n}\n\n/**\n * Metadata about a key.\n */\nexport interface Key {\n  name: string | number;\n  prefix: string;\n  suffix: string;\n  pattern: string;\n  modifier: string;\n}\n\n/**\n * A token is a string (nothing special) or key metadata (capture group).\n */\nexport type Token = string | Key;\n\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path: RegExp, keys?: Key[]): RegExp {\n  if (!keys) return path;\n\n  const groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n\n  let index = 0;\n  let execResult = groupsRegex.exec(path.source);\n  while (execResult) {\n    keys.push({\n      // Use parenthesized substring match if available, index otherwise\n      name: execResult[1] || index++,\n      prefix: \"\",\n      suffix: \"\",\n      modifier: \"\",\n      pattern: \"\",\n    });\n    execResult = groupsRegex.exec(path.source);\n  }\n\n  return path;\n}\n\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(\n  paths: Array<string | RegExp>,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions,\n): RegExp {\n  const parts = paths.map((path) => pathToRegexp(path, keys, options).source);\n  return new RegExp(`(?:${parts.join(\"|\")})`, flags(options));\n}\n\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(\n  path: string,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions,\n) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n\nexport interface TokensToRegexpOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * When `true` the regexp won't allow an optional trailing delimiter to match. (default: `false`)\n   */\n  strict?: boolean;\n  /**\n   * When `true` the regexp will match to the end of the string. (default: `true`)\n   */\n  end?: boolean;\n  /**\n   * When `true` the regexp will match from the beginning of the string. (default: `true`)\n   */\n  start?: boolean;\n  /**\n   * Sets the final character for non-ending optimistic matches. (default: `/`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters that can also be \"end\" characters.\n   */\n  endsWith?: string;\n  /**\n   * Encode path tokens for use in the `RegExp`.\n   */\n  encode?: (value: string) => string;\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(\n  tokens: Token[],\n  keys?: Key[],\n  options: TokensToRegexpOptions = {},\n) {\n  const {\n    strict = false,\n    start = true,\n    end = true,\n    encode = (x: string) => x,\n    delimiter = \"/#?\",\n    endsWith = \"\",\n  } = options;\n  const endsWithRe = `[${escapeString(endsWith)}]|$`;\n  const delimiterRe = `[${escapeString(delimiter)}]`;\n  let route = start ? \"^\" : \"\";\n\n  // Iterate over the tokens and create our regexp string.\n  for (const token of tokens) {\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      const prefix = escapeString(encode(token.prefix));\n      const suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            const mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;\n          } else {\n            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;\n          }\n        } else {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            throw new TypeError(\n              `Can not repeat \"${token.name}\" without a prefix and suffix`,\n            );\n          }\n\n          route += `(${token.pattern})${token.modifier}`;\n        }\n      } else {\n        route += `(?:${prefix}${suffix})${token.modifier}`;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += `${delimiterRe}?`;\n\n    route += !options.endsWith ? \"$\" : `(?=${endsWithRe})`;\n  } else {\n    const endToken = tokens[tokens.length - 1];\n    const isEndDelimited =\n      typeof endToken === \"string\"\n        ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n        : endToken === undefined;\n\n    if (!strict) {\n      route += `(?:${delimiterRe}(?=${endsWithRe}))?`;\n    }\n\n    if (!isEndDelimited) {\n      route += `(?=${delimiterRe}|${endsWithRe})`;\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\n/**\n * Supported `path-to-regexp` input types.\n */\nexport type Path = string | RegExp | Array<string | RegExp>;\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(\n  path: Path,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions,\n) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n", "import type { AnyObject, ChildrenCallback, Route, RouteContext } from './types.js';\r\n\r\nexport function isObject(o: unknown): o is object {\r\n  // guard against null passing the typeof check\r\n  return typeof o === 'object' && !!o;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\nexport function isFunction(f: unknown): f is Function {\r\n  return typeof f === 'function';\r\n}\r\n\r\nexport function isString(s: unknown): s is string {\r\n  return typeof s === 'string';\r\n}\r\n\r\nexport function toArray<T>(value: T | readonly T[] = []): readonly T[] {\r\n  return Array.isArray(value) ? value : [value];\r\n}\r\n\r\nexport function log(msg: string): string {\r\n  return `[Vaadin.Router] ${msg}`;\r\n}\r\n\r\nexport class NotFoundError<T, R extends AnyObject, C extends AnyObject> extends Error {\r\n  readonly code: number;\r\n  readonly context: RouteContext<T, R, C>;\r\n\r\n  constructor(context: RouteContext<T, R, C>) {\r\n    super(log(`Page not found (${context.pathname})`));\r\n    this.context = context;\r\n    this.code = 404;\r\n  }\r\n}\r\n\r\nexport const notFoundResult = Symbol('NotFoundResult');\r\nexport type NotFoundResult = typeof notFoundResult;\r\n\r\nexport function getNotFoundError<T, R extends AnyObject, C extends AnyObject>(\r\n  context: RouteContext<T, R, C>,\r\n): NotFoundError<T, R, C> {\r\n  return new NotFoundError(context);\r\n}\r\n\r\nexport function resolvePath(path?: string | readonly string[]): string {\r\n  return (Array.isArray(path) ? path[0] : path) ?? '';\r\n}\r\n\r\nexport function getRoutePath<T, R extends AnyObject, C extends AnyObject>(route: Route<T, R, C> | undefined): string {\r\n  return resolvePath(route?.path);\r\n}\r\n\r\nexport function unwrapChildren<T, R extends AnyObject, C extends AnyObject>(\r\n  children: ChildrenCallback<T, R, C> | ReadonlyArray<Route<T, R, C>> | undefined,\r\n): ReadonlyArray<Route<T, R, C>> | undefined {\r\n  return Array.isArray<ReadonlyArray<Route<T, R, C>>>(children) && children.length > 0 ? children : undefined;\r\n}\r\n", "/**\r\n * Universal Router (https://www.kriasoft.com/universal-router/)\r\n *\r\n * Copyright (c) 2015-present Kriasoft.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE.txt file in the root directory of this source tree.\r\n */\r\n\r\nimport { type Key, pathToRegexp } from 'path-to-regexp';\r\nimport type { Writable } from 'type-fest';\r\nimport type { IndexedParams } from '../types.js';\r\nimport { resolvePath } from './utils.js';\r\n\r\nexport interface RegExpExecOptArray extends ReadonlyArray<string | undefined> {\r\n  0: string;\r\n  index: number;\r\n  input: string;\r\n}\r\n\r\ntype Matcher = Readonly<{\r\n  keys: readonly Key[];\r\n  pattern: RegExp;\r\n}>;\r\n\r\nexport type Match = Readonly<{\r\n  keys: readonly Key[];\r\n  params: IndexedParams;\r\n  path: string;\r\n}>;\r\n\r\nconst cache = new Map<string, Matcher>();\r\n// see https://github.com/pillarjs/path-to-regexp/issues/148\r\ncache.set('|false', {\r\n  keys: [],\r\n  pattern: /(?:)/u,\r\n});\r\n\r\nfunction decodeParam(val: string): string {\r\n  try {\r\n    return decodeURIComponent(val);\r\n  } catch {\r\n    return val;\r\n  }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/max-params\r\nfunction matchPath(\r\n  routePath: string,\r\n  path?: string[] | string,\r\n  exact: boolean = false,\r\n  parentKeys: readonly Key[] = [],\r\n  parentParams?: IndexedParams,\r\n): Match | null {\r\n  const cacheKey = `${routePath}|${String(exact)}`;\r\n  const _path = resolvePath(path);\r\n  let regexp = cache.get(cacheKey);\r\n\r\n  if (!regexp) {\r\n    const keys: Key[] = [];\r\n    regexp = {\r\n      keys,\r\n      pattern: pathToRegexp(routePath, keys, {\r\n        end: exact,\r\n        strict: routePath === '',\r\n      }),\r\n    };\r\n    cache.set(cacheKey, regexp);\r\n  }\r\n\r\n  const m: RegExpExecOptArray | null = regexp.pattern.exec(_path);\r\n  if (!m) {\r\n    return null;\r\n  }\r\n\r\n  const params: Writable<IndexedParams> = { ...parentParams };\r\n\r\n  for (let i = 1; i < m.length; i++) {\r\n    const key = regexp.keys[i - 1];\r\n    const prop = key.name;\r\n    const value = m[i];\r\n    if (value !== undefined || !Object.hasOwn(params, prop)) {\r\n      if (key.modifier === '+' || key.modifier === '*') {\r\n        // by default, as of path-to-regexp 6.0.0, the default delimiters\r\n        // are `/`, `#` and `?`.\r\n        params[prop] = value ? value.split(/[/?#]/u).map(decodeParam) : [];\r\n      } else {\r\n        params[prop] = value ? decodeParam(value) : value!;\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    keys: [...parentKeys, ...regexp.keys],\r\n    params,\r\n    path: m[0],\r\n  };\r\n}\r\n\r\nexport default matchPath;\r\n", "/**\r\n * Universal Router (https://www.kriasoft.com/universal-router/)\r\n *\r\n * Copyright (c) 2015-present Kriasoft.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE.txt file in the root directory of this source tree.\r\n */\r\n\r\nimport type { Key } from 'path-to-regexp';\r\nimport matchPath, { type Match } from './matchPath.js';\r\nimport type { AnyObject, IndexedParams, Route } from './types.js';\r\nimport { getRoutePath, unwrapChildren } from './utils.js';\r\n\r\nexport type MatchWithRoute<T, R extends AnyObject, C extends AnyObject> = Match &\r\n  Readonly<{\r\n    route: Route<T, R, C>;\r\n  }>;\r\n\r\ntype RouteMatchIterator<T, R extends AnyObject, C extends AnyObject> = Iterator<\r\n  MatchWithRoute<T, R, C>,\r\n  undefined,\r\n  Route<T, R, C> | undefined\r\n>;\r\n\r\n/**\r\n * Traverses the routes tree and matches its nodes to the given pathname from\r\n * the root down to the leaves. Each match consumes a part of the pathname and\r\n * the matching process continues for as long as there is a matching child\r\n * route for the remaining part of the pathname.\r\n *\r\n * The returned value is a lazily evaluated iterator.\r\n *\r\n * The leading \"/\" in a route path matters only for the root of the routes\r\n * tree (or if all parent routes are \"\"). In all other cases a leading \"/\" in\r\n * a child route path has no significance.\r\n *\r\n * The trailing \"/\" in a _route path_ matters only for the leaves of the\r\n * routes tree. A leaf route with a trailing \"/\" matches only a pathname that\r\n * also has a trailing \"/\".\r\n *\r\n * The trailing \"/\" in a route path does not affect matching of child routes\r\n * in any way.\r\n *\r\n * The trailing \"/\" in a _pathname_ generally does not matter (except for\r\n * the case of leaf nodes described above).\r\n *\r\n * The \"\" and \"/\" routes have special treatment:\r\n *  1. as a single route\r\n *     the \"\" and \"/\" routes match only the \"\" and \"/\" pathnames respectively\r\n *  2. as a parent in the routes tree\r\n *     the \"\" route matches any pathname without consuming any part of it\r\n *     the \"/\" route matches any absolute pathname consuming its leading \"/\"\r\n *  3. as a leaf in the routes tree\r\n *     the \"\" and \"/\" routes match only if the entire pathname is consumed by\r\n *         the parent routes chain. In this case \"\" and \"/\" are equivalent.\r\n *  4. several directly nested \"\" or \"/\" routes\r\n *     - directly nested \"\" or \"/\" routes are 'squashed' (i.e. nesting two\r\n *       \"/\" routes does not require a double \"/\" in the pathname to match)\r\n *     - if there are only \"\" in the parent routes chain, no part of the\r\n *       pathname is consumed, and the leading \"/\" in the child routes' paths\r\n *       remains significant\r\n *\r\n * Side effect:\r\n *   - the routes tree `{ path: '' }` matches only the '' pathname\r\n *   - the routes tree `{ path: '', children: [ { path: '' } ] }` matches any\r\n *     pathname (for the tree root)\r\n *\r\n * Prefix matching can be enabled also by `children: true`.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/max-params\r\nfunction matchRoute<T, R extends AnyObject, C extends AnyObject>(\r\n  route: Route<T, R, C>,\r\n  pathname: string,\r\n  ignoreLeadingSlash?: boolean,\r\n  parentKeys?: readonly Key[],\r\n  parentParams?: IndexedParams,\r\n): Iterator<MatchWithRoute<T, R, C>, undefined, Route<T, R, C> | undefined> {\r\n  let match: Match | null;\r\n  let childMatches: RouteMatchIterator<T, R, C> | null;\r\n  let childIndex = 0;\r\n  let routepath = getRoutePath(route);\r\n  if (routepath.startsWith('/')) {\r\n    if (ignoreLeadingSlash) {\r\n      routepath = routepath.substring(1);\r\n    }\r\n    // eslint-disable-next-line no-param-reassign\r\n    ignoreLeadingSlash = true;\r\n  }\r\n\r\n  return {\r\n    next(routeToSkip?: Route<T, R, C>): IteratorResult<MatchWithRoute<T, R, C>, undefined> {\r\n      if (route === routeToSkip) {\r\n        return { done: true, value: undefined };\r\n      }\r\n\r\n      route.__children ??= unwrapChildren(route.children);\r\n      const children = route.__children ?? [];\r\n      const exact = !route.__children && !route.children;\r\n\r\n      if (!match) {\r\n        match = matchPath(routepath, pathname, exact, parentKeys, parentParams);\r\n\r\n        if (match) {\r\n          return {\r\n            value: {\r\n              keys: match.keys,\r\n              params: match.params,\r\n              path: match.path,\r\n              route,\r\n            },\r\n          };\r\n        }\r\n      }\r\n\r\n      if (match && children.length > 0) {\r\n        while (childIndex < children.length) {\r\n          if (!childMatches) {\r\n            const childRoute = children[childIndex];\r\n            childRoute.parent = route;\r\n\r\n            let matchedLength = match.path.length;\r\n            if (matchedLength > 0 && pathname.charAt(matchedLength) === '/') {\r\n              matchedLength += 1;\r\n            }\r\n\r\n            childMatches = matchRoute(\r\n              childRoute,\r\n              pathname.substring(matchedLength),\r\n              ignoreLeadingSlash,\r\n              match.keys,\r\n              match.params,\r\n            );\r\n          }\r\n\r\n          const childMatch = childMatches.next(routeToSkip);\r\n          if (!childMatch.done) {\r\n            return {\r\n              done: false,\r\n              value: childMatch.value,\r\n            };\r\n          }\r\n\r\n          childMatches = null;\r\n          childIndex += 1;\r\n        }\r\n      }\r\n\r\n      return { done: true, value: undefined };\r\n    },\r\n  };\r\n}\r\n\r\nexport default matchRoute;\r\n", "/**\r\n * Universal Router (https://www.kriasoft.com/universal-router/)\r\n *\r\n * Copyright (c) 2015-present Kriasoft.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE.txt file in the root directory of this source tree.\r\n */\r\nimport type { ActionResult, AnyObject, MaybePromise, RouteContext } from './types.js';\r\nimport { isFunction } from './utils.js';\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\r\nexport default function resolveRoute<T, R extends AnyObject, C extends AnyObject>(\r\n  context: RouteContext<T, R, C>,\r\n): MaybePromise<ActionResult<T | RouteContext<T, R, C>>> {\r\n  if (isFunction(context.route.action)) {\r\n    // @ts-expect-error: ignore \"never\" type here\r\n    return context.route.action(context);\r\n  }\r\n  return undefined;\r\n}\r\n", "/**\r\n * Universal Router (https://www.kriasoft.com/universal-router/)\r\n *\r\n * Copyright (c) 2015-present Kriasoft.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE.txt file in the root directory of this source tree.\r\n */\r\nimport type { EmptyObject } from 'type-fest';\r\nimport matchRoute, { type MatchWithRoute } from './matchRoute.js';\r\nimport defaultResolveRoute from './resolveRoute.js';\r\nimport type {\r\n  ActionResult,\r\n  AnyObject,\r\n  BasicRoutePart,\r\n  Match,\r\n  MaybePromise,\r\n  ResolveContext,\r\n  Route,\r\n  RouteContext,\r\n} from './types.js';\r\nimport { getNotFoundError, getRoutePath, isString, NotFoundError, notFoundResult, toArray } from './utils.js';\r\n\r\nfunction isDescendantRoute<T, R extends AnyObject, C extends AnyObject>(\r\n  route?: Route<T, R, C>,\r\n  maybeParent?: Route<T, R, C>,\r\n) {\r\n  let _route = route;\r\n  while (_route) {\r\n    _route = _route.parent;\r\n    if (_route === maybeParent) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction isRouteContext<T, R extends AnyObject, C extends AnyObject>(value: unknown): value is RouteContext<T, R, C> {\r\n  return (\r\n    !!value &&\r\n    typeof value === 'object' &&\r\n    'next' in value &&\r\n    'params' in value &&\r\n    'result' in value &&\r\n    'route' in value\r\n  );\r\n}\r\n\r\nexport interface ResolutionErrorOptions extends ErrorOptions {\r\n  code?: number;\r\n}\r\n\r\nexport class ResolutionError<T, R extends AnyObject = EmptyObject, C extends AnyObject = EmptyObject> extends Error {\r\n  readonly code?: number;\r\n  readonly context: RouteContext<T, R, C>;\r\n\r\n  constructor(context: RouteContext<T, R, C>, options?: ResolutionErrorOptions) {\r\n    let errorMessage = `Path '${context.pathname}' is not properly resolved due to an error.`;\r\n    const routePath = getRoutePath(context.route);\r\n    if (routePath) {\r\n      errorMessage += ` Resolution had failed on route: '${routePath}'`;\r\n    }\r\n    super(errorMessage, options);\r\n    this.code = options?.code;\r\n    this.context = context;\r\n  }\r\n\r\n  warn(): void {\r\n    console.warn(this.message);\r\n  }\r\n}\r\n\r\nfunction updateChainForRoute<T, R extends AnyObject, C extends AnyObject>(\r\n  context: RouteContext<T, R, C>,\r\n  match: Match<T, R, C>,\r\n) {\r\n  const { path, route } = match;\r\n\r\n  if (route && !route.__synthetic) {\r\n    const item = { path, route };\r\n    if (route.parent && context.chain) {\r\n      for (let i = context.chain.length - 1; i >= 0; i--) {\r\n        if (context.chain[i].route === route.parent) {\r\n          break;\r\n        }\r\n\r\n        context.chain.pop();\r\n      }\r\n    }\r\n    context.chain?.push(item);\r\n  }\r\n}\r\n\r\nexport type ErrorHandlerCallback<T> = (error: unknown) => T;\r\n\r\nexport type ResolveRouteCallback<T, R extends AnyObject, C extends AnyObject> = (\r\n  context: RouteContext<T, R, C>,\r\n) => MaybePromise<ActionResult<T | RouteContext<T, R, C>>>;\r\n\r\nexport type ResolverOptions<T, R extends AnyObject, C extends AnyObject> = Readonly<{\r\n  baseUrl?: string;\r\n  context?: RouteContext<T, R, C>;\r\n  errorHandler?: ErrorHandlerCallback<T>;\r\n  resolveRoute?: ResolveRouteCallback<T, R, C>;\r\n}>;\r\n\r\nexport default class Resolver<T = unknown, R extends AnyObject = EmptyObject, C extends AnyObject = EmptyObject> {\r\n  /**\r\n   * The base URL for all routes in the router instance. By default,\r\n   * if the base element exists in the `<head>`, vaadin-router\r\n   * takes the `<base href>` attribute value, resolved against the current\r\n   * `document.URL`.\r\n   */\r\n  readonly baseUrl: string;\r\n  #context: RouteContext<T, R, C>;\r\n  readonly errorHandler?: ErrorHandlerCallback<T>;\r\n  readonly resolveRoute: ResolveRouteCallback<T, R, C>;\r\n  readonly #root: BasicRoutePart<T, R, C>;\r\n\r\n  constructor(routes: ReadonlyArray<Route<T, R, C>> | Route<T, R, C>, options?: ResolverOptions<T, R, C>);\r\n  constructor(\r\n    routes: ReadonlyArray<Route<T, R, C>> | Route<T, R, C>,\r\n    { baseUrl = '', context, errorHandler, resolveRoute = defaultResolveRoute }: ResolverOptions<T, R, C> = {},\r\n  ) {\r\n    if (Object(routes) !== routes) {\r\n      throw new TypeError('Invalid routes');\r\n    }\r\n\r\n    this.baseUrl = baseUrl;\r\n    this.errorHandler = errorHandler;\r\n    this.resolveRoute = resolveRoute;\r\n\r\n    if (Array.isArray(routes)) {\r\n      // @FIXME: We should have a route array instead of a single route object\r\n      // to avoid type clash because of a missing `R` part of a route.\r\n      // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\r\n      this.#root = {\r\n        __children: routes,\r\n        __synthetic: true,\r\n        action: () => undefined,\r\n        path: '',\r\n      };\r\n    } else {\r\n      this.#root = { ...routes, parent: undefined };\r\n    }\r\n\r\n    this.#context = {\r\n      ...context!,\r\n      hash: '',\r\n      // eslint-disable-next-line @typescript-eslint/require-await\r\n      async next() {\r\n        return notFoundResult;\r\n      },\r\n      params: {},\r\n      pathname: '',\r\n      resolver: this,\r\n      route: this.#root as Route<T, R, C>,\r\n      search: '',\r\n      chain: [],\r\n    };\r\n  }\r\n\r\n  get root(): Route<T, R, C> {\r\n    return this.#root as Route<T, R, C>;\r\n  }\r\n\r\n  get context(): RouteContext<T, R, C> {\r\n    return this.#context;\r\n  }\r\n\r\n  /**\r\n   * If the baseUrl property is set, transforms the baseUrl and returns the full\r\n   * actual `base` string for using in the `new URL(path, base);` and for\r\n   * prepernding the paths with. The returned base ends with a trailing slash.\r\n   *\r\n   * Otherwise, returns empty string.\r\n   */\r\n  protected get __effectiveBaseUrl(): string {\r\n    return this.baseUrl ? new URL(this.baseUrl, document.baseURI || document.URL).href.replace(/[^/]*$/u, '') : '';\r\n  }\r\n\r\n  /**\r\n   * Returns the current list of routes (as a shallow copy). Adding / removing\r\n   * routes to / from the returned array does not affect the routing config,\r\n   * but modifying the route objects does.\r\n   *\r\n   * @public\r\n   */\r\n  getRoutes(): ReadonlyArray<Route<T, R, C>> {\r\n    return [...(this.#root.__children ?? [])];\r\n  }\r\n\r\n  /**\r\n   * Removes all existing routes from the routing config.\r\n   *\r\n   * @public\r\n   */\r\n  removeRoutes(): void {\r\n    this.#root.__children = [];\r\n  }\r\n\r\n  /**\r\n   * Asynchronously resolves the given pathname, i.e. finds all routes matching\r\n   * the pathname and tries resolving them one after another in the order they\r\n   * are listed in the routes config until the first non-null result.\r\n   *\r\n   * Returns a promise that is fulfilled with the return value of an object that consists of the first\r\n   * route handler result that returns something other than `null` or `undefined` and context used to get this result.\r\n   *\r\n   * If no route handlers return a non-null result, or if no route matches the\r\n   * given pathname the returned promise is rejected with a 'page not found'\r\n   * `Error`.\r\n   *\r\n   * @param pathnameOrContext - the pathname to\r\n   *    resolve or a context object with a `pathname` property and other\r\n   *    properties to pass to the route resolver functions.\r\n   */\r\n  async resolve(pathnameOrContext: ResolveContext<C> | string): Promise<ActionResult<RouteContext<T, R, C>>> {\r\n    const self = this;\r\n    const context: RouteContext<T, R, C> = {\r\n      ...this.#context,\r\n      ...(isString(pathnameOrContext) ? { pathname: pathnameOrContext } : pathnameOrContext),\r\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\r\n      next,\r\n    };\r\n    const match = matchRoute(\r\n      this.#root as Route<T, R, C>,\r\n      this.__normalizePathname(context.pathname) ?? context.pathname,\r\n      !!this.baseUrl,\r\n    );\r\n    const resolve = this.resolveRoute;\r\n    let matches: IteratorResult<MatchWithRoute<T, R, C>, undefined> | null = null;\r\n    let nextMatches: IteratorResult<MatchWithRoute<T, R, C>, undefined> | null = null;\r\n    let currentContext = context;\r\n\r\n    async function next(\r\n      resume: boolean = false,\r\n      parent: Route<T, R, C> | undefined = matches?.value?.route,\r\n      prevResult?: ActionResult<T | RouteContext<T, R, C>>,\r\n    ): Promise<ActionResult<RouteContext<T, R, C>>> {\r\n      const routeToSkip = prevResult === null ? matches?.value?.route : undefined;\r\n      matches = nextMatches ?? match.next(routeToSkip);\r\n      nextMatches = null;\r\n\r\n      if (!resume) {\r\n        if (!!matches.done || !isDescendantRoute(matches.value.route, parent)) {\r\n          nextMatches = matches;\r\n          return notFoundResult;\r\n        }\r\n      }\r\n\r\n      if (matches.done) {\r\n        throw getNotFoundError(context);\r\n      }\r\n\r\n      currentContext = {\r\n        ...context,\r\n        params: matches.value.params,\r\n        route: matches.value.route,\r\n        chain: currentContext.chain?.slice(),\r\n      };\r\n      updateChainForRoute(currentContext, matches.value);\r\n\r\n      const resolution = await resolve(currentContext);\r\n\r\n      if (resolution !== null && resolution !== undefined && resolution !== notFoundResult) {\r\n        currentContext.result = isRouteContext<T, R, C>(resolution) ? resolution.result : resolution;\r\n        self.#context = currentContext;\r\n        return currentContext;\r\n      }\r\n      return await next(resume, parent, resolution);\r\n    }\r\n\r\n    try {\r\n      return await next(true, this.#root as Route<T, R, C>);\r\n    } catch (error: unknown) {\r\n      const _error =\r\n        error instanceof NotFoundError\r\n          ? error\r\n          : new ResolutionError(currentContext as RouteContext<R>, { code: 500, cause: error });\r\n\r\n      if (this.errorHandler) {\r\n        currentContext.result = this.errorHandler(_error);\r\n        return currentContext;\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets the routing config (replacing the existing one).\r\n   *\r\n   * @param routes - a single route or an array of those\r\n   *    (the array is shallow copied)\r\n   */\r\n  setRoutes(routes: ReadonlyArray<Route<T, R, C>> | Route<T, R, C>): void {\r\n    this.#root.__children = [...toArray(routes)];\r\n  }\r\n\r\n  /**\r\n   * If the baseUrl is set, matches the pathname with the router\u2019s baseUrl,\r\n   * and returns the local pathname with the baseUrl stripped out.\r\n   *\r\n   * If the pathname does not match the baseUrl, returns undefined.\r\n   *\r\n   * If the `baseUrl` is not set, returns the unmodified pathname argument.\r\n   */\r\n  protected __normalizePathname(pathname: string): string | undefined {\r\n    if (!this.baseUrl) {\r\n      // No base URL, no need to transform the pathname.\r\n      return pathname;\r\n    }\r\n\r\n    const base = this.__effectiveBaseUrl;\r\n    // Convert pathname to a valid URL constructor argument\r\n    const url = pathname.startsWith('/') ? new URL(base).origin + pathname : `./${pathname}`;\r\n    const normalizedUrl = new URL(url, base).href;\r\n    if (normalizedUrl.startsWith(base)) {\r\n      return normalizedUrl.slice(base.length);\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Appends one or several routes to the routing config and returns the\r\n   * effective routing config after the operation.\r\n   *\r\n   * @param routes - a single route or an array of those\r\n   *    (the array is shallow copied)\r\n   */\r\n  protected addRoutes(routes: ReadonlyArray<Route<T, R, C>> | Route<T, R, C>): ReadonlyArray<Route<T, R, C>> {\r\n    this.#root.__children = [...(this.#root.__children ?? []), ...toArray(routes)];\r\n    return this.getRoutes();\r\n  }\r\n}\r\n", "/**\r\n * Universal Router (https://www.kriasoft.com/universal-router/)\r\n *\r\n * Copyright (c) 2015-present Kriasoft.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE.txt file in the root directory of this source tree.\r\n */\r\n\r\nimport { parse, type ParseOptions, type Token, tokensToFunction, type TokensToFunctionOptions } from 'path-to-regexp';\r\nimport type { EmptyObject, Writable } from 'type-fest';\r\nimport Resolver from './resolver.js';\r\nimport type { AnyObject, ChildrenCallback, IndexedParams, Params, Route } from './types.js';\r\nimport { getRoutePath, isString } from './utils.js';\r\n\r\nexport type UrlParams = Readonly<Record<string, ReadonlyArray<number | string> | number | string>>;\r\n\r\nfunction cacheRoutes<T, R extends AnyObject, C extends AnyObject>(\r\n  routesByName: Map<string, Array<Route<T, R, C>>>,\r\n  route: Route<T, R, C>,\r\n  routes?: ReadonlyArray<Route<T, R, C>> | ChildrenCallback<T, R, C>,\r\n  cacheKeyProvider?: (route: Route<T, R, C>) => string | undefined,\r\n): void {\r\n  const name = route.name ?? cacheKeyProvider?.(route);\r\n  if (name) {\r\n    if (routesByName.has(name)) {\r\n      routesByName.get(name)?.push(route);\r\n    } else {\r\n      routesByName.set(name, [route]);\r\n    }\r\n  }\r\n\r\n  if (Array.isArray(routes)) {\r\n    for (const childRoute of routes) {\r\n      childRoute.parent = route;\r\n      cacheRoutes(routesByName, childRoute, childRoute.__children ?? childRoute.children, cacheKeyProvider);\r\n    }\r\n  }\r\n}\r\n\r\nfunction getRouteByName<T, R extends AnyObject, C extends AnyObject>(\r\n  routesByName: Map<string, Array<Route<T, R, C>>>,\r\n  routeName: string,\r\n): Route<T, R, C> | undefined {\r\n  const routes = routesByName.get(routeName);\r\n\r\n  if (routes) {\r\n    if (routes.length > 1) {\r\n      throw new Error(`Duplicate route with name \"${routeName}\".` + ` Try seting unique 'name' route properties.`);\r\n    }\r\n\r\n    return routes[0];\r\n  }\r\n\r\n  return undefined;\r\n}\r\n\r\nexport type StringifyQueryParams = (params: UrlParams) => string;\r\n\r\nexport type GenerateUrlOptions<T, R extends AnyObject, C extends AnyObject> = ParseOptions &\r\n  Readonly<{\r\n    /**\r\n     * Add a query string to generated url based on unknown route params.\r\n     */\r\n    stringifyQueryParams?: StringifyQueryParams;\r\n    /**\r\n     * Generates a unique route name based on all parent routes with the specified separator.\r\n     */\r\n    uniqueRouteNameSep?: string;\r\n    cacheKeyProvider?(route: Route<T, R, C>): string | undefined;\r\n  }> &\r\n  TokensToFunctionOptions;\r\n\r\ntype RouteCacheRecord = Readonly<{\r\n  keys: Record<string, true>;\r\n  tokens: Token[];\r\n}>;\r\n\r\nexport type UrlGenerator = (routeName: string, params?: Params) => string;\r\n\r\nfunction generateUrls<T = unknown, R extends AnyObject = EmptyObject, C extends AnyObject = EmptyObject>(\r\n  resolver: Resolver<T, R, C>,\r\n  options: GenerateUrlOptions<T, R, C> = {},\r\n): UrlGenerator {\r\n  if (!(resolver instanceof Resolver)) {\r\n    throw new TypeError('An instance of Resolver is expected');\r\n  }\r\n\r\n  const cache = new Map<string, RouteCacheRecord>();\r\n  const routesByName = new Map<string, Array<Route<T, R, C>>>();\r\n\r\n  return (routeName, params) => {\r\n    let route = getRouteByName(routesByName, routeName);\r\n    if (!route) {\r\n      routesByName.clear(); // clear cache\r\n      cacheRoutes(routesByName, resolver.root, resolver.root.__children, options.cacheKeyProvider);\r\n\r\n      route = getRouteByName(routesByName, routeName);\r\n      if (!route) {\r\n        throw new Error(`Route \"${routeName}\" not found`);\r\n      }\r\n    }\r\n\r\n    let cached: RouteCacheRecord | undefined = route.fullPath ? cache.get(route.fullPath) : undefined;\r\n    if (!cached) {\r\n      let fullPath = getRoutePath(route);\r\n      let rt = route.parent;\r\n      while (rt) {\r\n        const path = getRoutePath(rt);\r\n        if (path) {\r\n          fullPath = `${path.replace(/\\/$/u, '')}/${fullPath.replace(/^\\//u, '')}`;\r\n        }\r\n        rt = rt.parent;\r\n      }\r\n      const tokens = parse(fullPath);\r\n      const keys: Record<string, true> = Object.create(null);\r\n      for (const item of tokens) {\r\n        if (!isString(item)) {\r\n          keys[item.name] = true;\r\n        }\r\n      }\r\n      cached = { keys, tokens };\r\n      cache.set(fullPath, cached);\r\n      route.fullPath = fullPath;\r\n    }\r\n\r\n    const toPath = tokensToFunction(cached.tokens, { encode: encodeURIComponent, ...options });\r\n    let url = toPath(params) || '/';\r\n\r\n    if (options.stringifyQueryParams && params) {\r\n      const queryParams: Writable<IndexedParams> = {};\r\n      for (const [key, value] of Object.entries(params)) {\r\n        if (!(key in cached.keys) && value) {\r\n          queryParams[key] = value;\r\n        }\r\n      }\r\n      const query = options.stringifyQueryParams(queryParams as UrlParams);\r\n      if (query) {\r\n        url += query.startsWith('?') ? query : `?${query}`;\r\n      }\r\n    }\r\n\r\n    return url;\r\n  };\r\n}\r\n\r\nexport default generateUrls;\r\n", "const DEV_MODE_CODE_REGEXP =\n  /\\/\\*[\\*!]\\s+vaadin-dev-mode:start([\\s\\S]*)vaadin-dev-mode:end\\s+\\*\\*\\//i;\n\nconst FlowClients = window.Vaadin && window.Vaadin.Flow && window.Vaadin.Flow.clients;\n\nfunction isMinified() {\n  function test() {\n    /** vaadin-dev-mode:start\n    return false;\n    vaadin-dev-mode:end **/\n    return true;\n  }\n  return uncommentAndRun(test);\n}\n\nfunction isDevelopmentMode() {\n  try {\n    if (isForcedDevelopmentMode()) {\n      return true;\n    }\n\n    if (!isLocalhost()) {\n      return false;\n    }\n\n    if (FlowClients) {\n      return !isFlowProductionMode();\n    }\n\n    return !isMinified();\n  } catch (e) {\n    // Some error in this code, assume production so no further actions will be taken\n    return false;\n  }\n}\n\nfunction isForcedDevelopmentMode() {\n  return localStorage.getItem(\"vaadin.developmentmode.force\");\n}\n\nfunction isLocalhost() {\n  return ([\"localhost\",\"127.0.0.1\"].indexOf(window.location.hostname) >= 0);\n}\n\nfunction isFlowProductionMode() {\n  if (FlowClients) {\n    const productionModeApps = Object.keys(FlowClients)\n      .map(key => FlowClients[key])\n      .filter(client => client.productionMode);\n    if (productionModeApps.length > 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction uncommentAndRun(callback, args) {\n  if (typeof callback !== 'function') {\n    return;\n  }\n\n  const match = DEV_MODE_CODE_REGEXP.exec(callback.toString());\n  if (match) {\n    try {\n      // requires CSP: script-src 'unsafe-eval'\n      callback = new Function(match[1]);\n    } catch (e) {\n      // eat the exception\n      console.log('vaadin-development-mode-detector: uncommentAndRun() failed', e)\n    }\n  }\n\n  return callback(args);\n}\n\n// A guard against polymer-modulizer removing the window.Vaadin\n// initialization above.\nwindow['Vaadin'] = window['Vaadin'] || {};\n\n/**\n * Inspects the source code of the given `callback` function for\n * specially-marked _commented_ code. If such commented code is found in the\n * callback source, uncomments and runs that code instead of the callback\n * itself. Otherwise runs the callback as is.\n *\n * The optional arguments are passed into the callback / uncommented code,\n * the result is returned.\n *\n * See the `isMinified()` function source code in this file for an example.\n *\n */\nexport const runIfDevelopmentMode = function(callback, args) {\n  if (window.Vaadin.developmentMode) {\n    return uncommentAndRun(callback, args);\n  }\n};\n\nif (window.Vaadin.developmentMode === undefined) {\n  window.Vaadin.developmentMode = isDevelopmentMode();\n}\n", "/* This file is autogenerated from src/vaadin-usage-statistics.tpl.html */\n/*\n\nThis script gathers usage statistics from the application running in development mode.\n\nStatistics gathering is automatically disabled and excluded from production builds.\n\nFor details and to opt-out, see https://github.com/vaadin/vaadin-usage-statistics.\n\n*/\n/*\n  FIXME(polymer-modulizer): the above comments were extracted\n  from HTML and may be out of place here. Review them and\n  then delete this comment!\n*/\nimport { runIfDevelopmentMode } from '@vaadin/vaadin-development-mode-detector/vaadin-development-mode-detector.js';\n\nfunction maybeGatherAndSendStats() {\n  /*! vaadin-dev-mode:start\n  (function () {\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar getPolymerVersion = function getPolymerVersion() {\n  return window.Polymer && window.Polymer.version;\n};\n\nvar StatisticsGatherer = function () {\n  function StatisticsGatherer(logger) {\n    classCallCheck(this, StatisticsGatherer);\n\n    this.now = new Date().getTime();\n    this.logger = logger;\n  }\n\n  createClass(StatisticsGatherer, [{\n    key: 'frameworkVersionDetectors',\n    value: function frameworkVersionDetectors() {\n      return {\n        'Flow': function Flow() {\n          if (window.Vaadin && window.Vaadin.Flow && window.Vaadin.Flow.clients) {\n            var flowVersions = Object.keys(window.Vaadin.Flow.clients).map(function (key) {\n              return window.Vaadin.Flow.clients[key];\n            }).filter(function (client) {\n              return client.getVersionInfo;\n            }).map(function (client) {\n              return client.getVersionInfo().flow;\n            });\n            if (flowVersions.length > 0) {\n              return flowVersions[0];\n            }\n          }\n        },\n        'Vaadin Framework': function VaadinFramework() {\n          if (window.vaadin && window.vaadin.clients) {\n            var frameworkVersions = Object.values(window.vaadin.clients).filter(function (client) {\n              return client.getVersionInfo;\n            }).map(function (client) {\n              return client.getVersionInfo().vaadinVersion;\n            });\n            if (frameworkVersions.length > 0) {\n              return frameworkVersions[0];\n            }\n          }\n        },\n        'AngularJs': function AngularJs() {\n          if (window.angular && window.angular.version && window.angular.version) {\n            return window.angular.version.full;\n          }\n        },\n        'Angular': function Angular() {\n          if (window.ng) {\n            var tags = document.querySelectorAll(\"[ng-version]\");\n            if (tags.length > 0) {\n              return tags[0].getAttribute(\"ng-version\");\n            }\n            return \"Unknown\";\n          }\n        },\n        'Backbone.js': function BackboneJs() {\n          if (window.Backbone) {\n            return window.Backbone.VERSION;\n          }\n        },\n        'React': function React() {\n          var reactSelector = '[data-reactroot], [data-reactid]';\n          if (!!document.querySelector(reactSelector)) {\n            // React does not publish the version by default\n            return \"unknown\";\n          }\n        },\n        'Ember': function Ember() {\n          if (window.Em && window.Em.VERSION) {\n            return window.Em.VERSION;\n          } else if (window.Ember && window.Ember.VERSION) {\n            return window.Ember.VERSION;\n          }\n        },\n        'jQuery': function (_jQuery) {\n          function jQuery() {\n            return _jQuery.apply(this, arguments);\n          }\n\n          jQuery.toString = function () {\n            return _jQuery.toString();\n          };\n\n          return jQuery;\n        }(function () {\n          if (typeof jQuery === 'function' && jQuery.prototype.jquery !== undefined) {\n            return jQuery.prototype.jquery;\n          }\n        }),\n        'Polymer': function Polymer() {\n          var version = getPolymerVersion();\n          if (version) {\n            return version;\n          }\n        },\n        'LitElement': function LitElement() {\n          var version = window.litElementVersions && window.litElementVersions[0];\n          if (version) {\n            return version;\n          }\n        },\n        'LitHtml': function LitHtml() {\n          var version = window.litHtmlVersions && window.litHtmlVersions[0];\n          if (version) {\n            return version;\n          }\n        },\n        'Vue.js': function VueJs() {\n          if (window.Vue) {\n            return window.Vue.version;\n          }\n        }\n      };\n    }\n  }, {\n    key: 'getUsedVaadinElements',\n    value: function getUsedVaadinElements(elements) {\n      var version = getPolymerVersion();\n      var elementClasses = void 0;\n      // NOTE: In case you edit the code here, YOU MUST UPDATE any statistics reporting code in Flow.\n      // Check all locations calling the method getEntries() in\n      // https://github.com/vaadin/flow/blob/master/flow-server/src/main/java/com/vaadin/flow/internal/UsageStatistics.java#L106\n      // Currently it is only used by BootstrapHandler.\n      if (version && version.indexOf('2') === 0) {\n        // Polymer 2: components classes are stored in window.Vaadin\n        elementClasses = Object.keys(window.Vaadin).map(function (c) {\n          return window.Vaadin[c];\n        }).filter(function (c) {\n          return c.is;\n        });\n      } else {\n        // Polymer 3: components classes are stored in window.Vaadin.registrations\n        elementClasses = window.Vaadin.registrations || [];\n      }\n      elementClasses.forEach(function (klass) {\n        var version = klass.version ? klass.version : \"0.0.0\";\n        elements[klass.is] = { version: version };\n      });\n    }\n  }, {\n    key: 'getUsedVaadinThemes',\n    value: function getUsedVaadinThemes(themes) {\n      ['Lumo', 'Material'].forEach(function (themeName) {\n        var theme;\n        var version = getPolymerVersion();\n        if (version && version.indexOf('2') === 0) {\n          // Polymer 2: themes are stored in window.Vaadin\n          theme = window.Vaadin[themeName];\n        } else {\n          // Polymer 3: themes are stored in custom element registry\n          theme = customElements.get('vaadin-' + themeName.toLowerCase() + '-styles');\n        }\n        if (theme && theme.version) {\n          themes[themeName] = { version: theme.version };\n        }\n      });\n    }\n  }, {\n    key: 'getFrameworks',\n    value: function getFrameworks(frameworks) {\n      var detectors = this.frameworkVersionDetectors();\n      Object.keys(detectors).forEach(function (framework) {\n        var detector = detectors[framework];\n        try {\n          var version = detector();\n          if (version) {\n            frameworks[framework] = { version: version };\n          }\n        } catch (e) {}\n      });\n    }\n  }, {\n    key: 'gather',\n    value: function gather(storage) {\n      var storedStats = storage.read();\n      var gatheredStats = {};\n      var types = [\"elements\", \"frameworks\", \"themes\"];\n\n      types.forEach(function (type) {\n        gatheredStats[type] = {};\n        if (!storedStats[type]) {\n          storedStats[type] = {};\n        }\n      });\n\n      var previousStats = JSON.stringify(storedStats);\n\n      this.getUsedVaadinElements(gatheredStats.elements);\n      this.getFrameworks(gatheredStats.frameworks);\n      this.getUsedVaadinThemes(gatheredStats.themes);\n\n      var now = this.now;\n      types.forEach(function (type) {\n        var keys = Object.keys(gatheredStats[type]);\n        keys.forEach(function (key) {\n          if (!storedStats[type][key] || _typeof(storedStats[type][key]) != _typeof({})) {\n            storedStats[type][key] = { firstUsed: now };\n          }\n          // Discards any previously logged version number\n          storedStats[type][key].version = gatheredStats[type][key].version;\n          storedStats[type][key].lastUsed = now;\n        });\n      });\n\n      var newStats = JSON.stringify(storedStats);\n      storage.write(newStats);\n      if (newStats != previousStats && Object.keys(storedStats).length > 0) {\n        this.logger.debug(\"New stats: \" + newStats);\n      }\n    }\n  }]);\n  return StatisticsGatherer;\n}();\n\nvar StatisticsStorage = function () {\n  function StatisticsStorage(key) {\n    classCallCheck(this, StatisticsStorage);\n\n    this.key = key;\n  }\n\n  createClass(StatisticsStorage, [{\n    key: 'read',\n    value: function read() {\n      var localStorageStatsString = localStorage.getItem(this.key);\n      try {\n        return JSON.parse(localStorageStatsString ? localStorageStatsString : '{}');\n      } catch (e) {\n        return {};\n      }\n    }\n  }, {\n    key: 'write',\n    value: function write(data) {\n      localStorage.setItem(this.key, data);\n    }\n  }, {\n    key: 'clear',\n    value: function clear() {\n      localStorage.removeItem(this.key);\n    }\n  }, {\n    key: 'isEmpty',\n    value: function isEmpty() {\n      var storedStats = this.read();\n      var empty = true;\n      Object.keys(storedStats).forEach(function (key) {\n        if (Object.keys(storedStats[key]).length > 0) {\n          empty = false;\n        }\n      });\n\n      return empty;\n    }\n  }]);\n  return StatisticsStorage;\n}();\n\nvar StatisticsSender = function () {\n  function StatisticsSender(url, logger) {\n    classCallCheck(this, StatisticsSender);\n\n    this.url = url;\n    this.logger = logger;\n  }\n\n  createClass(StatisticsSender, [{\n    key: 'send',\n    value: function send(data, errorHandler) {\n      var logger = this.logger;\n\n      if (navigator.onLine === false) {\n        logger.debug(\"Offline, can't send\");\n        errorHandler();\n        return;\n      }\n      logger.debug(\"Sending data to \" + this.url);\n\n      var req = new XMLHttpRequest();\n      req.withCredentials = true;\n      req.addEventListener(\"load\", function () {\n        // Stats sent, nothing more to do\n        logger.debug(\"Response: \" + req.responseText);\n      });\n      req.addEventListener(\"error\", function () {\n        logger.debug(\"Send failed\");\n        errorHandler();\n      });\n      req.addEventListener(\"abort\", function () {\n        logger.debug(\"Send aborted\");\n        errorHandler();\n      });\n      req.open(\"POST\", this.url);\n      req.setRequestHeader(\"Content-Type\", \"application/json\");\n      req.send(data);\n    }\n  }]);\n  return StatisticsSender;\n}();\n\nvar StatisticsLogger = function () {\n  function StatisticsLogger(id) {\n    classCallCheck(this, StatisticsLogger);\n\n    this.id = id;\n  }\n\n  createClass(StatisticsLogger, [{\n    key: '_isDebug',\n    value: function _isDebug() {\n      return localStorage.getItem(\"vaadin.\" + this.id + \".debug\");\n    }\n  }, {\n    key: 'debug',\n    value: function debug(msg) {\n      if (this._isDebug()) {\n        console.info(this.id + \": \" + msg);\n      }\n    }\n  }]);\n  return StatisticsLogger;\n}();\n\nvar UsageStatistics = function () {\n  function UsageStatistics() {\n    classCallCheck(this, UsageStatistics);\n\n    this.now = new Date();\n    this.timeNow = this.now.getTime();\n    this.gatherDelay = 10; // Delay between loading this file and gathering stats\n    this.initialDelay = 24 * 60 * 60;\n\n    this.logger = new StatisticsLogger(\"statistics\");\n    this.storage = new StatisticsStorage(\"vaadin.statistics.basket\");\n    this.gatherer = new StatisticsGatherer(this.logger);\n    this.sender = new StatisticsSender(\"https://tools.vaadin.com/usage-stats/submit\", this.logger);\n  }\n\n  createClass(UsageStatistics, [{\n    key: 'maybeGatherAndSend',\n    value: function maybeGatherAndSend() {\n      var _this = this;\n\n      if (localStorage.getItem(UsageStatistics.optOutKey)) {\n        return;\n      }\n      this.gatherer.gather(this.storage);\n      setTimeout(function () {\n        _this.maybeSend();\n      }, this.gatherDelay * 1000);\n    }\n  }, {\n    key: 'lottery',\n    value: function lottery() {\n      return true;\n    }\n  }, {\n    key: 'currentMonth',\n    value: function currentMonth() {\n      return this.now.getYear() * 12 + this.now.getMonth();\n    }\n  }, {\n    key: 'maybeSend',\n    value: function maybeSend() {\n      var firstUse = Number(localStorage.getItem(UsageStatistics.firstUseKey));\n      var monthProcessed = Number(localStorage.getItem(UsageStatistics.monthProcessedKey));\n\n      if (!firstUse) {\n        // Use a grace period to avoid interfering with tests, incognito mode etc\n        firstUse = this.timeNow;\n        localStorage.setItem(UsageStatistics.firstUseKey, firstUse);\n      }\n\n      if (this.timeNow < firstUse + this.initialDelay * 1000) {\n        this.logger.debug(\"No statistics will be sent until the initial delay of \" + this.initialDelay + \"s has passed\");\n        return;\n      }\n      if (this.currentMonth() <= monthProcessed) {\n        this.logger.debug(\"This month has already been processed\");\n        return;\n      }\n      localStorage.setItem(UsageStatistics.monthProcessedKey, this.currentMonth());\n      // Use random sampling\n      if (this.lottery()) {\n        this.logger.debug(\"Congratulations, we have a winner!\");\n      } else {\n        this.logger.debug(\"Sorry, no stats from you this time\");\n        return;\n      }\n\n      this.send();\n    }\n  }, {\n    key: 'send',\n    value: function send() {\n      // Ensure we have the latest data\n      this.gatherer.gather(this.storage);\n\n      // Read, send and clean up\n      var data = this.storage.read();\n      data[\"firstUse\"] = Number(localStorage.getItem(UsageStatistics.firstUseKey));\n      data[\"usageStatisticsVersion\"] = UsageStatistics.version;\n      var info = 'This request contains usage statistics gathered from the application running in development mode. \\n\\nStatistics gathering is automatically disabled and excluded from production builds.\\n\\nFor details and to opt-out, see https://github.com/vaadin/vaadin-usage-statistics.\\n\\n\\n\\n';\n      var self = this;\n      this.sender.send(info + JSON.stringify(data), function () {\n        // Revert the 'month processed' flag\n        localStorage.setItem(UsageStatistics.monthProcessedKey, self.currentMonth() - 1);\n      });\n    }\n  }], [{\n    key: 'version',\n    get: function get$1() {\n      return '2.1.2';\n    }\n  }, {\n    key: 'firstUseKey',\n    get: function get$1() {\n      return 'vaadin.statistics.firstuse';\n    }\n  }, {\n    key: 'monthProcessedKey',\n    get: function get$1() {\n      return 'vaadin.statistics.monthProcessed';\n    }\n  }, {\n    key: 'optOutKey',\n    get: function get$1() {\n      return 'vaadin.statistics.optout';\n    }\n  }]);\n  return UsageStatistics;\n}();\n\ntry {\n  window.Vaadin = window.Vaadin || {};\n  window.Vaadin.usageStatsChecker = window.Vaadin.usageStatsChecker || new UsageStatistics();\n  window.Vaadin.usageStatsChecker.maybeGatherAndSend();\n} catch (e) {\n  // Intentionally ignored as this is not a problem in the app being developed\n}\n\n}());\n\n  vaadin-dev-mode:end **/\n}\n\nexport const usageStatistics = function() {\n  if (typeof runIfDevelopmentMode === 'function') {\n    return runIfDevelopmentMode(maybeGatherAndSendStats);\n  }\n};\n", "export function __REGISTER__(feature, vaadinObj = (window.Vaadin ??= {})) {\r\n  vaadinObj.registrations ??= [];\r\n  vaadinObj.registrations.push({\r\n    is: feature ? `${__NAME__}/${feature}` : __NAME__,\r\n    version: __VERSION__,\r\n  });\r\n}\r\n", "import { usageStatistics } from '@vaadin/vaadin-usage-statistics/vaadin-usage-statistics.js';\r\n\r\n// @ts-expect-error: Generated function\r\n// eslint-disable-next-line @typescript-eslint/no-unsafe-call\r\n__REGISTER__();\r\n\r\nusageStatistics();\r\n", "const willAnimate = (elem: Element) => {\r\n  const name = getComputedStyle(elem).getPropertyValue('animation-name');\r\n  return name && name !== 'none';\r\n};\r\n\r\nconst waitForAnimation = (elem: Element, cb: () => void) => {\r\n  const listener = () => {\r\n    elem.removeEventListener('animationend', listener);\r\n    cb();\r\n  };\r\n  elem.addEventListener('animationend', listener);\r\n};\r\n\r\nasync function animate(elem: Element, className: string): Promise<void> {\r\n  elem.classList.add(className);\r\n\r\n  return await new Promise((resolve: () => void) => {\r\n    if (willAnimate(elem)) {\r\n      const rect = elem.getBoundingClientRect();\r\n      const size = `height: ${rect.bottom - rect.top}px; width: ${rect.right - rect.left}px`;\r\n      elem.setAttribute('style', `position: absolute; ${size}`);\r\n      waitForAnimation(elem, () => {\r\n        elem.classList.remove(className);\r\n        elem.removeAttribute('style');\r\n        resolve();\r\n      });\r\n    } else {\r\n      elem.classList.remove(className);\r\n      resolve();\r\n    }\r\n  });\r\n}\r\n\r\nexport default animate;\r\n", "import { compile } from 'path-to-regexp';\r\nimport type Resolver from './resolver/resolver.js';\r\nimport { isFunction, isObject, isString, log, toArray } from './resolver/utils.js';\r\nimport type { Router } from './router.js';\r\nimport type {\r\n  ActionResult,\r\n  AnyObject,\r\n  ChainItem,\r\n  IndexedParams,\r\n  RedirectResult,\r\n  Route,\r\n  RouteContext,\r\n  RouterLocation,\r\n  WebComponentInterface,\r\n} from './types.js';\r\n\r\nexport function ensureRoute<R extends AnyObject, C extends AnyObject>(route?: Route<R, C>): void {\r\n  if (!route || !isString(route.path)) {\r\n    throw new Error(\r\n      log(`Expected route config to be an object with a \"path\" string property, or an array of such objects`),\r\n    );\r\n  }\r\n\r\n  if (\r\n    !isFunction(route.action) &&\r\n    !Array.isArray(route.children) &&\r\n    !isFunction(route.children) &&\r\n    !isString(route.component) &&\r\n    !isString(route.redirect)\r\n  ) {\r\n    throw new Error(\r\n      log(\r\n        `Expected route config \"${route.path}\" to include either \"component, redirect\" ` +\r\n          `or \"action\" function but none found.`,\r\n      ),\r\n    );\r\n  }\r\n\r\n  if (route.redirect) {\r\n    ['bundle', 'component'].forEach((overriddenProp) => {\r\n      if (overriddenProp in route) {\r\n        console.warn(\r\n          log(\r\n            `Route config \"${String(route.path)}\" has both \"redirect\" and \"${overriddenProp}\" properties, ` +\r\n              `and \"redirect\" will always override the latter. Did you mean to only use \"${overriddenProp}\"?`,\r\n          ),\r\n        );\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nexport function ensureRoutes<R extends AnyObject, C extends AnyObject>(\r\n  routes: Route<R, C> | ReadonlyArray<Route<R, C>>,\r\n): void {\r\n  toArray(routes).forEach((route) => ensureRoute(route));\r\n}\r\n\r\nexport function copyContextWithoutNext<R extends AnyObject, C extends AnyObject>({\r\n  next: _,\r\n  ...context\r\n}: RouteContext<R, C>): Omit<RouteContext<R, C>, 'next'> {\r\n  return context;\r\n}\r\n\r\nexport function getPathnameForRouter<T, R extends AnyObject, C extends AnyObject>(\r\n  pathname: string,\r\n  router: Resolver<T, R, C>,\r\n): string {\r\n  // @ts-expect-error: __effectiveBaseUrl is a private property\r\n  const base = router.__effectiveBaseUrl;\r\n  return base ? new URL(pathname.replace(/^\\//u, ''), base).pathname : pathname;\r\n}\r\n\r\nexport function getMatchedPath(pathItems: ReadonlyArray<Readonly<{ path: string }>>): string {\r\n  return pathItems\r\n    .map((pathItem) => pathItem.path)\r\n    .reduce((a, b) => {\r\n      if (b.length) {\r\n        return `${a.replace(/\\/$/u, '')}/${b.replace(/^\\//u, '')}`;\r\n      }\r\n      return a;\r\n    }, '');\r\n}\r\n\r\nexport function getRoutePath<R extends AnyObject, C extends AnyObject>(chain: ReadonlyArray<ChainItem<R, C>>): string {\r\n  return getMatchedPath(chain.map((chainItem) => chainItem.route));\r\n}\r\n\r\nexport type ResolverOnlyContext<R extends AnyObject, C extends AnyObject> = Readonly<{ resolver: Router<R, C> }>;\r\n\r\ntype PartialRouteContext<R extends AnyObject, C extends AnyObject> = Readonly<{\r\n  chain?: ReadonlyArray<ChainItem<R, C>>;\r\n  hash?: string;\r\n  params?: IndexedParams;\r\n  pathname?: string;\r\n  resolver?: Router<R, C>;\r\n  redirectFrom?: string;\r\n  search?: string;\r\n}>;\r\n\r\nexport function createLocation<R extends AnyObject, C extends AnyObject>({\r\n  resolver,\r\n}: ResolverOnlyContext<R, C>): RouterLocation<R, C>;\r\nexport function createLocation<R extends AnyObject, C extends AnyObject>(\r\n  context: RouteContext<R, C>,\r\n  route?: Route<R, C>,\r\n): RouterLocation<R, C>;\r\nexport function createLocation<R extends AnyObject, C extends AnyObject>(\r\n  { chain = [], hash = '', params = {}, pathname = '', redirectFrom, resolver, search = '' }: PartialRouteContext<R, C>,\r\n  route?: Route<R, C>,\r\n): RouterLocation<R, C> {\r\n  const routes = chain.map((item) => item.route);\r\n  return {\r\n    baseUrl: resolver?.baseUrl ?? '',\r\n    getUrl: (userParams = {}) =>\r\n      resolver ? getPathnameForRouter(compile(getRoutePath(chain))({ ...params, ...userParams } as Partial<Record<string, string[]>>), resolver) : '',\r\n    hash,\r\n    params,\r\n    pathname,\r\n    redirectFrom,\r\n    route: route ?? (Array.isArray(routes) ? routes.at(-1) : undefined) ?? null,\r\n    routes,\r\n    search,\r\n    searchParams: new URLSearchParams(search),\r\n  };\r\n}\r\n\r\nexport function createRedirect<R extends AnyObject, C extends AnyObject>(\r\n  context: RouteContext<R, C>,\r\n  pathname: string,\r\n): RedirectResult {\r\n  const params = { ...context.params };\r\n  return {\r\n    redirect: {\r\n      from: context.pathname,\r\n      params,\r\n      pathname,\r\n    },\r\n  };\r\n}\r\n\r\nexport function renderElement<R extends AnyObject, C extends AnyObject, E extends WebComponentInterface<R, C>>(\r\n  context: RouteContext<R, C>,\r\n  element: E,\r\n): E {\r\n  element.location = createLocation(context);\r\n\r\n  if (context.chain) {\r\n    const index = context.chain.map((item) => item.route).indexOf(context.route);\r\n    context.chain[index].element = element;\r\n  }\r\n\r\n  return element;\r\n}\r\n\r\nexport function maybeCall<R, A extends unknown[], O extends object>(\r\n  callback: ((this: O, ...args: A) => R) | undefined,\r\n  thisArg: O,\r\n  ...args: A\r\n): R | undefined {\r\n  if (typeof callback === 'function') {\r\n    return callback.apply(thisArg, args);\r\n  }\r\n\r\n  return undefined;\r\n}\r\n\r\nexport function amend<\r\n  A extends readonly unknown[],\r\n  N extends keyof O,\r\n  O extends AnyObject & { [key in N]: (this: O, ...args: A) => ActionResult | undefined },\r\n>(fn: keyof O, obj: O | undefined, ...args: A): (result: ActionResult) => ActionResult | undefined {\r\n  return (result: ActionResult) => {\r\n    if (result && isObject(result) && ('cancel' in result || 'redirect' in result)) {\r\n      return result;\r\n    }\r\n\r\n    return maybeCall(obj?.[fn], obj!, ...args);\r\n  };\r\n}\r\n\r\nexport function processNewChildren<R extends AnyObject, C extends AnyObject>(\r\n  newChildren: Route<R, C> | ReadonlyArray<Route<R, C>> | undefined | void,\r\n  route: Route<R, C>,\r\n): void {\r\n  if (!Array.isArray(newChildren) && !isObject(newChildren)) {\r\n    throw new Error(\r\n      log(\r\n        `Incorrect \"children\" value for the route ${String(route.path)}: expected array or object, but got ${String(\r\n          newChildren,\r\n        )}`,\r\n      ),\r\n    );\r\n  }\r\n\r\n  const children = toArray(newChildren);\r\n  children.forEach((child) => ensureRoute(child));\r\n  route.__children = children;\r\n}\r\n\r\nexport function fireRouterEvent(type: string, detail: unknown): boolean {\r\n  return !window.dispatchEvent(new CustomEvent(`vaadin-router-${type}`, { cancelable: type === 'go', detail }));\r\n}\r\n\r\nexport function logValue(value: unknown): string {\r\n  if (typeof value !== 'object') {\r\n    return String(value);\r\n  }\r\n\r\n  const [stringType = 'Unknown'] = / (.*)\\]$/u.exec(String(value)) ?? [];\r\n  if (stringType === 'Object' || stringType === 'Array') {\r\n    return `${stringType} ${JSON.stringify(value)}`;\r\n  }\r\n  return stringType;\r\n}\r\n", "import type { NavigationTrigger } from '../types.js';\r\nimport { fireRouterEvent } from '../utils.js';\r\n\r\n/* istanbul ignore next: coverage is calculated in Chrome, this code is for IE */\r\nfunction getAnchorOrigin(anchor: HTMLAnchorElement) {\r\n  // IE11: on HTTP and HTTPS the default port is not included into\r\n  // window.location.origin, so won't include it here either.\r\n  const { port, protocol } = anchor;\r\n  const defaultHttp = protocol === 'http:' && port === '80';\r\n  const defaultHttps = protocol === 'https:' && port === '443';\r\n  const host =\r\n    defaultHttp || defaultHttps\r\n      ? anchor.hostname // does not include the port number (e.g. www.example.org)\r\n      : anchor.host; // does include the port number (e.g. www.example.org:80)\r\n  return `${protocol}//${host}`;\r\n}\r\n\r\nfunction getNormalizedNodeName(e: EventTarget): string | undefined {\r\n  if (!(e instanceof Element)) {\r\n    return undefined;\r\n  }\r\n\r\n  return e.nodeName.toLowerCase();\r\n}\r\n\r\n// TODO: Name correctly when the type purpose is known\r\ntype __Pathable = Readonly<{\r\n  path?: readonly EventTarget[];\r\n}>;\r\n\r\n// The list of checks is not complete:\r\n//  - SVG support is missing\r\n//  - the 'rel' attribute is not considered\r\nfunction vaadinRouterGlobalClickHandler(event: MouseEvent & __Pathable) {\r\n  // ignore the click if the default action is prevented\r\n  if (event.defaultPrevented) {\r\n    return;\r\n  }\r\n\r\n  // ignore the click if not with the primary mouse button\r\n  if (event.button !== 0) {\r\n    return;\r\n  }\r\n\r\n  // ignore the click if a modifier key is pressed\r\n  if (event.shiftKey || event.ctrlKey || event.altKey || event.metaKey) {\r\n    return;\r\n  }\r\n\r\n  // find the <a> element that the click is at (or within)\r\n  let anchorCandidate = event.target;\r\n  const path = event instanceof MouseEvent ? event.composedPath() : ((event as __Pathable).path ?? []);\r\n\r\n  // FIXME(web-padawan): `Symbol.iterator` used by webcomponentsjs is broken for arrays\r\n  // example to check: `for...of` loop here throws the \"Not yet implemented\" error\r\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of\r\n  for (let i = 0; i < path.length; i++) {\r\n    const target = path[i];\r\n    if ('nodeName' in target && (target as Element).nodeName.toLowerCase() === 'a') {\r\n      anchorCandidate = target;\r\n      break;\r\n    }\r\n  }\r\n\r\n  while (anchorCandidate && anchorCandidate instanceof Node && getNormalizedNodeName(anchorCandidate) !== 'a') {\r\n    anchorCandidate = anchorCandidate.parentNode;\r\n  }\r\n\r\n  // ignore the click if not at an <a> element\r\n  if (!anchorCandidate || getNormalizedNodeName(anchorCandidate) !== 'a') {\r\n    return;\r\n  }\r\n\r\n  const anchor = anchorCandidate as HTMLAnchorElement;\r\n\r\n  // ignore the click if the <a> element has a non-default target\r\n  if (anchor.target && anchor.target.toLowerCase() !== '_self') {\r\n    return;\r\n  }\r\n\r\n  // ignore the click if the <a> element has the 'download' attribute\r\n  if (anchor.hasAttribute('download')) {\r\n    return;\r\n  }\r\n\r\n  // ignore the click if the <a> element has the 'router-ignore' attribute\r\n  if (anchor.hasAttribute('router-ignore')) {\r\n    return;\r\n  }\r\n\r\n  // ignore the click if the target URL is a fragment on the current page\r\n  if (anchor.pathname === window.location.pathname && anchor.hash !== '') {\r\n    return;\r\n  }\r\n\r\n  // ignore the click if the target is external to the app\r\n  // In IE11 HTMLAnchorElement does not have the `origin` property\r\n  const origin = anchor.origin || getAnchorOrigin(anchor);\r\n  if (origin !== window.location.origin) {\r\n    return;\r\n  }\r\n\r\n  // if none of the above, convert the click into a navigation event\r\n  const { hash, pathname, search } = anchor;\r\n  if (fireRouterEvent('go', { hash, pathname, search }) && event instanceof MouseEvent) {\r\n    event.preventDefault();\r\n    // for a click event, the scroll is reset to the top position.\r\n    // FIXME: undefined here?\r\n    if (event.type === 'click') {\r\n      window.scrollTo(0, 0);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * A navigation trigger for Vaadin Router that translated clicks on `<a>` links\r\n * into Vaadin Router navigation events.\r\n *\r\n * Only regular clicks on in-app links are translated (primary mouse button, no\r\n * modifier keys, the target href is within the app's URL space).\r\n */\r\nconst CLICK: NavigationTrigger = {\r\n  activate() {\r\n    window.document.addEventListener('click', vaadinRouterGlobalClickHandler);\r\n  },\r\n\r\n  inactivate() {\r\n    window.document.removeEventListener('click', vaadinRouterGlobalClickHandler);\r\n  },\r\n};\r\n\r\nexport default CLICK;\r\n", "import type { NavigationTrigger } from '../types.js';\r\nimport { fireRouterEvent } from '../utils.js';\r\n\r\nfunction vaadinRouterGlobalPopstateHandler(event: PopStateEvent) {\r\n  if (event.state === 'vaadin-router-ignore') {\r\n    return;\r\n  }\r\n  const { hash, pathname, search } = window.location;\r\n  fireRouterEvent('go', { hash, pathname, search });\r\n}\r\n\r\n/**\r\n * A navigation trigger for Vaadin Router that translates popstate events into\r\n * Vaadin Router navigation events.\r\n */\r\nconst POPSTATE: NavigationTrigger = {\r\n  activate() {\r\n    window.addEventListener('popstate', vaadinRouterGlobalPopstateHandler);\r\n  },\r\n\r\n  inactivate() {\r\n    window.removeEventListener('popstate', vaadinRouterGlobalPopstateHandler);\r\n  },\r\n};\r\n\r\nexport default POPSTATE;\r\n", "import type { NavigationTrigger } from '../types.js';\r\nimport CLICK from './click.js';\r\nimport POPSTATE from './popstate.js';\r\n\r\nlet triggers: readonly NavigationTrigger[] = [];\r\n\r\nconst DEFAULT_TRIGGERS = {\r\n  CLICK,\r\n  POPSTATE,\r\n} as const;\r\n\r\nexport { DEFAULT_TRIGGERS };\r\n\r\nexport function setNavigationTriggers(newTriggers: readonly NavigationTrigger[] = []): void {\r\n  triggers.forEach((trigger) => trigger.inactivate());\r\n\r\n  newTriggers.forEach((trigger) => trigger.activate());\r\n\r\n  triggers = newTriggers;\r\n}\r\n", "/* eslint-disable @typescript-eslint/consistent-return */\r\nimport { compile } from 'path-to-regexp';\r\nimport type { EmptyObject, Writable } from 'type-fest';\r\nimport generateUrls from './resolver/generateUrls.js';\r\nimport Resolver from './resolver/resolver.js';\r\nimport './router-config.js';\r\nimport { getNotFoundError, isFunction, isObject, isString, log, notFoundResult } from './resolver/utils.js';\r\nimport animate from './transitions/animate.js';\r\nimport { DEFAULT_TRIGGERS, setNavigationTriggers } from './triggers/navigation.js';\r\nimport type {\r\n  ActionResult,\r\n  AnyObject,\r\n  Commands,\r\n  ChainItem,\r\n  ContextExtension,\r\n  EmptyCommands,\r\n  NavigationTrigger,\r\n  Params,\r\n  PreventAndRedirectCommands,\r\n  PreventCommands,\r\n  PreventResult,\r\n  RedirectContextInfo,\r\n  RedirectResult,\r\n  ResolveContext,\r\n  Route,\r\n  RouteContext,\r\n  RouteExtension,\r\n  RouterLocation,\r\n  WebComponentInterface,\r\n  RouterOptions,\r\n  ActionValue,\r\n  NextResult,\r\n} from './types.js';\r\nimport {\r\n  amend,\r\n  copyContextWithoutNext,\r\n  createLocation,\r\n  createRedirect,\r\n  ensureRoutes,\r\n  fireRouterEvent,\r\n  getMatchedPath,\r\n  getPathnameForRouter,\r\n  logValue,\r\n  maybeCall,\r\n  processNewChildren,\r\n  renderElement,\r\n} from './utils.js';\r\n\r\nconst MAX_REDIRECT_COUNT = 256;\r\n\r\nfunction prevent(): PreventResult {\r\n  return { cancel: true };\r\n}\r\n\r\nconst rootContext: RouteContext = {\r\n  __renderId: -1,\r\n  params: {},\r\n  route: {\r\n    __synthetic: true,\r\n    children: [],\r\n    path: '',\r\n    action() {\r\n      return undefined;\r\n    },\r\n  },\r\n  pathname: '',\r\n  // eslint-disable-next-line @typescript-eslint/require-await\r\n  async next() {\r\n    return notFoundResult;\r\n  },\r\n};\r\n\r\n/**\r\n * A simple client-side router for single-page applications. It uses\r\n * express-style middleware and has a first-class support for Web Components and\r\n * lazy-loading. Works great in Polymer and non-Polymer apps.\r\n *\r\n * Use `new Router(outlet, options)` to create a new Router instance.\r\n *\r\n * * The `outlet` parameter is a reference to the DOM node to render\r\n *   the content into.\r\n *\r\n * * The `options` parameter is an optional object with options. The following\r\n *   keys are supported:\r\n *   * `baseUrl` \u2014 the initial value for [\r\n *     the `baseUrl` property\r\n *   ](#/classes/Router#property-baseUrl)\r\n *\r\n * The Router instance is automatically subscribed to navigation events\r\n * on `window`.\r\n *\r\n * See [Live Examples](#/classes/Router/demos/demo/index.html) for the detailed usage demo and code snippets.\r\n *\r\n * See also detailed API docs for the following methods, for the advanced usage:\r\n *\r\n * * [setOutlet](#/classes/Router#method-setOutlet) \u2013 should be used to configure the outlet.\r\n * * [setTriggers](#/classes/Router#method-setTriggers) \u2013 should be used to configure the navigation events.\r\n * * [setRoutes](#/classes/Router#method-setRoutes) \u2013 should be used to configure the routes.\r\n *\r\n * Only `setRoutes` has to be called manually, others are automatically invoked when creating a new instance.\r\n */\r\nexport class Router<R extends AnyObject = EmptyObject, C extends AnyObject = EmptyObject> extends Resolver<\r\n  ActionValue,\r\n  RouteExtension<R, C>,\r\n  ContextExtension<R, C>\r\n> {\r\n  /**\r\n   * Contains read-only information about the current router location:\r\n   * pathname, active routes, parameters. See the\r\n   * [Location type declaration](#/classes/RouterLocation)\r\n   * for more details.\r\n   */\r\n  location = createLocation({ resolver: this });\r\n\r\n  /**\r\n   * A promise that is settled after the current render cycle completes. If\r\n   * there is no render cycle in progress the promise is immediately settled\r\n   * with the last render cycle result.\r\n   */\r\n  ready: Promise<RouterLocation<R, C>> = Promise.resolve(this.location);\r\n\r\n  readonly #addedByRouter = new WeakSet<Element>();\r\n  readonly #createdByRouter = new WeakSet<Element>();\r\n  readonly #navigationEventHandler = this.#onNavigationEvent.bind(this);\r\n\r\n  #lastStartedRenderId = 0;\r\n  #outlet: Element | DocumentFragment | null | undefined;\r\n  private __previousContext?: RouteContext<R, C>;\r\n\r\n  #urlForName?: ReturnType<typeof generateUrls>;\r\n\r\n  #appearingContent: Element[] | null = null;\r\n  #disappearingContent: Element[] | null = null;\r\n\r\n  /**\r\n   * Creates a new Router instance with a given outlet, and\r\n   * automatically subscribes it to navigation events on the `window`.\r\n   * Using a constructor argument or a setter for outlet is equivalent:\r\n   *\r\n   * ```\r\n   * const router = new Router();\r\n   * router.setOutlet(outlet);\r\n   * ```\r\n   * @param outlet - a container to render the resolved route\r\n   * @param options - an optional object with options\r\n   */\r\n  constructor(outlet?: Element | DocumentFragment | null, options?: RouterOptions<R, C>) {\r\n    const baseElement = document.head.querySelector('base');\r\n    const baseHref = baseElement?.getAttribute('href');\r\n    super([], {\r\n      baseUrl: baseHref ? new URL(baseHref, document.URL).href.replace(/[^/]*$/u, '') : undefined,\r\n      ...options,\r\n      resolveRoute: async (context) => await this.#resolveRoute(context),\r\n    });\r\n\r\n    setNavigationTriggers(Object.values(DEFAULT_TRIGGERS));\r\n\r\n    this.setOutlet(outlet);\r\n    this.subscribe();\r\n  }\r\n\r\n  async #resolveRoute(context: RouteContext<R, C>): Promise<ActionResult | RouteContext<R, C>> {\r\n    const { route } = context;\r\n\r\n    if (isFunction(route.children)) {\r\n      let children = await route.children(copyContextWithoutNext(context));\r\n\r\n      // The route.children() callback might have re-written the\r\n      // route.children property instead of returning a value\r\n      if (!isFunction(route.children)) {\r\n        // eslint-disable-next-line no-param-reassign\r\n        ({ children } = route);\r\n      }\r\n      processNewChildren(children, route);\r\n    }\r\n\r\n    const commands: Commands = {\r\n      component: (component: string) => {\r\n        const element = document.createElement(component);\r\n        this.#createdByRouter.add(element);\r\n        return element;\r\n      },\r\n      prevent,\r\n      redirect: (path) => createRedirect(context, path),\r\n    };\r\n\r\n    return await Promise.resolve()\r\n      .then(async () => {\r\n        if (this.#isLatestRender(context)) {\r\n          // eslint-disable-next-line @typescript-eslint/unbound-method\r\n          return await maybeCall(route.action, route, context, commands);\r\n        }\r\n      })\r\n      .then((result) => {\r\n        if (result != null && (typeof result === 'object' || typeof result === 'symbol')) {\r\n          // Actions like `() => import('my-view.js')` are not expected to\r\n          // end the resolution, despite the result is not empty. Checking\r\n          // the result with a whitelist of values that end the resolution.\r\n          if (\r\n            result instanceof HTMLElement ||\r\n            result === notFoundResult ||\r\n            (isObject(result) && 'redirect' in result)\r\n          ) {\r\n            return result;\r\n          }\r\n        }\r\n\r\n        if (isString(route.redirect)) {\r\n          return commands.redirect(route.redirect);\r\n        }\r\n      })\r\n      .then((result) => {\r\n        if (result != null) {\r\n          return result;\r\n        }\r\n        if (isString(route.component)) {\r\n          return commands.component(route.component);\r\n        }\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Sets the router outlet (the DOM node where the content for the current\r\n   * route is inserted). Any content pre-existing in the router outlet is\r\n   * removed at the end of each render pass.\r\n   *\r\n   * @remarks\r\n   * This method is automatically invoked first time when creating a new Router\r\n   * instance.\r\n   *\r\n   * @param outlet - the DOM node where the content for the current route is\r\n   * inserted.\r\n   */\r\n  setOutlet(outlet?: Element | DocumentFragment | null): void {\r\n    if (outlet) {\r\n      this.#ensureOutlet(outlet);\r\n    }\r\n    this.#outlet = outlet;\r\n  }\r\n\r\n  /**\r\n   * Returns the current router outlet. The initial value is `undefined`.\r\n   *\r\n   * @returns the current router outlet (or `undefined`)\r\n   */\r\n  getOutlet(): Element | DocumentFragment | null | undefined {\r\n    return this.#outlet;\r\n  }\r\n\r\n  /**\r\n   * Sets the routing config (replacing the existing one) and triggers a\r\n   * navigation event so that the router outlet is refreshed according to the\r\n   * current `window.location` and the new routing config.\r\n   *\r\n   * Each route object may have the following properties, listed here in the processing order:\r\n   * * `path` \u2013 the route path (relative to the parent route if any) in the\r\n   * [express.js syntax](https://expressjs.com/en/guide/routing.html#route-paths).\r\n   *\r\n   * * `children` \u2013 an array of nested routes or a function that provides this\r\n   * array at the render time. The function can be synchronous or asynchronous:\r\n   * in the latter case the render is delayed until the returned promise is\r\n   * resolved. The `children` function is executed every time when this route is\r\n   * being rendered. This allows for dynamic route structures (e.g. backend-defined),\r\n   * but it might have a performance impact as well. In order to avoid calling\r\n   * the function on subsequent renders, you can override the `children` property\r\n   * of the route object and save the calculated array there\r\n   * (via `context.route.children = [ route1, route2, ...];`).\r\n   * Parent routes are fully resolved before resolving the children. Children\r\n   * 'path' values are relative to the parent ones.\r\n   *\r\n   * * `action` \u2013 the action that is executed before the route is resolved.\r\n   * The value for this property should be a function, accepting `context`\r\n   * and `commands` parameters described below. If present, this function is\r\n   * always invoked first, disregarding of the other properties' presence.\r\n   * The action can return a result directly or within a `Promise`, which\r\n   * resolves to the result. If the action result is an `HTMLElement` instance,\r\n   * a `commands.component(name)` result, a `commands.redirect(path)` result,\r\n   * or a `context.next()` result, the current route resolution is finished,\r\n   * and other route config properties are ignored.\r\n   * See also **Route Actions** section in [Live Examples](#/classes/Router/demos/demo/index.html).\r\n   *\r\n   * * `redirect` \u2013 other route's path to redirect to. Passes all route parameters to the redirect target.\r\n   * The target route should also be defined.\r\n   * See also **Redirects** section in [Live Examples](#/classes/Router/demos/demo/index.html).\r\n   *\r\n   * * `component` \u2013 the tag name of the Web Component to resolve the route to.\r\n   * The property is ignored when either an `action` returns the result or `redirect` property is present.\r\n   * If route contains the `component` property (or an action that return a component)\r\n   * and its child route also contains the `component` property, child route's component\r\n   * will be rendered as a light dom child of a parent component.\r\n   *\r\n   * * `name` \u2013 the string name of the route to use in the\r\n   * [`router.urlForName(name, params)`](#/classes/Router#method-urlForName)\r\n   * navigation helper method.\r\n   *\r\n   * For any route function (`action`, `children`) defined, the corresponding `route` object is available inside the\r\n   * callback through the `this` reference. If you need to access it, make sure you define the callback as a non-arrow\r\n   * function because arrow functions do not have their own `this` reference.\r\n   *\r\n   * `context` object that is passed to `action` function holds the following properties:\r\n   * * `context.pathname` \u2013 string with the pathname being resolved\r\n   *\r\n   * * `context.search` \u2013 search query string\r\n   *\r\n   * * `context.hash` \u2013 hash string\r\n   *\r\n   * * `context.params` \u2013 object with route parameters\r\n   *\r\n   * * `context.route` \u2013 object that holds the route that is currently being rendered.\r\n   *\r\n   * * `context.next()` \u2013 function for asynchronously getting the next route\r\n   * contents from the resolution chain (if any)\r\n   *\r\n   * `commands` object that is passed to `action` function has\r\n   * the following methods:\r\n   *\r\n   * * `commands.redirect(path)` \u2013 function that creates a redirect data\r\n   * for the path specified.\r\n   *\r\n   * * `commands.component(component)` \u2013 function that creates a new HTMLElement\r\n   * with current context. Note: the component created by this function is reused if visiting the same path twice in\r\n   * row.\r\n   *\r\n   * @param routes - a single route or an array of those\r\n   * @param skipRender - configure the router but skip rendering the\r\n   *     route corresponding to the current `window.location` values\r\n   */\r\n  // eslint-disable-next-line @typescript-eslint/no-misused-promises\r\n  override async setRoutes(\r\n    routes: Route<R, C> | ReadonlyArray<Route<R, C>>,\r\n    skipRender = false,\r\n  ): Promise<RouterLocation<R, C>> {\r\n    this.__previousContext = undefined;\r\n    this.#urlForName = undefined;\r\n    ensureRoutes(routes);\r\n    super.setRoutes(routes);\r\n    if (!skipRender) {\r\n      this.#onNavigationEvent();\r\n    }\r\n    return await this.ready;\r\n  }\r\n\r\n  protected override addRoutes(routes: Route<R, C> | ReadonlyArray<Route<R, C>>): ReadonlyArray<Route<R, C>> {\r\n    ensureRoutes(routes);\r\n    return super.addRoutes(routes);\r\n  }\r\n\r\n  /**\r\n   * Asynchronously resolves the given pathname and renders the resolved route\r\n   * component into the router outlet. If no router outlet is set at the time of\r\n   * calling this method, or at the time when the route resolution is completed,\r\n   * a `TypeError` is thrown.\r\n   *\r\n   * Returns a promise that is fulfilled with the router outlet DOM Element | DocumentFragment after\r\n   * the route component is created and inserted into the router outlet, or\r\n   * rejected if no route matches the given path.\r\n   *\r\n   * If another render pass is started before the previous one is completed, the\r\n   * result of the previous render pass is ignored.\r\n   *\r\n   * @param pathnameOrContext - the pathname to render or a context object with\r\n   * a `pathname` property, optional `search` and `hash` properties, and other\r\n   * properties to pass to the resolver.\r\n   * @param shouldUpdateHistory - update browser history with the rendered\r\n   * location\r\n   */\r\n  async render(\r\n    pathnameOrContext: string | ResolveContext,\r\n    shouldUpdateHistory: boolean = false,\r\n  ): Promise<RouterLocation<R, C>> {\r\n    this.#lastStartedRenderId += 1;\r\n    const renderId = this.#lastStartedRenderId;\r\n    const context = {\r\n      ...(rootContext as RouteContext<R, C>),\r\n      ...(isString(pathnameOrContext) ? { hash: '', search: '', pathname: pathnameOrContext } : pathnameOrContext),\r\n      __renderId: renderId,\r\n    } satisfies RouteContext<R, C>;\r\n\r\n    this.ready = this.#doRender(context, shouldUpdateHistory);\r\n    return await this.ready;\r\n  }\r\n\r\n  async #doRender(context: RouteContext<R, C>, shouldUpdateHistory: boolean) {\r\n    const { __renderId: renderId } = context;\r\n    try {\r\n      // Find the first route that resolves to a non-empty result\r\n      const ctx = await this.resolve(context);\r\n\r\n      // Process the result of this.resolve() and handle all special commands:\r\n      // (redirect / prevent / component). If the result is a 'component',\r\n      // then go deeper and build the entire chain of nested components matching\r\n      // the pathname. Also call all 'on before' callbacks along the way.\r\n      const contextWithChain = await this.#fullyResolveChain(ctx);\r\n\r\n      if (!this.#isLatestRender(contextWithChain)) {\r\n        return this.location;\r\n      }\r\n\r\n      const previousContext = this.__previousContext;\r\n\r\n      // Check if the render was prevented and make an early return in that case\r\n      if (contextWithChain === previousContext) {\r\n        // Replace the history with the previous context\r\n        // to make sure the URL stays the same.\r\n        this.#updateBrowserHistory(previousContext, true);\r\n        return this.location;\r\n      }\r\n\r\n      this.location = createLocation(contextWithChain);\r\n\r\n      if (shouldUpdateHistory) {\r\n        // Replace only if first render redirects, so that we don\u2019t leave\r\n        // the redirecting record in the history\r\n        this.#updateBrowserHistory(contextWithChain, renderId === 1);\r\n      }\r\n\r\n      fireRouterEvent('location-changed', {\r\n        router: this,\r\n        location: this.location,\r\n      });\r\n\r\n      // Skip detaching/re-attaching there are no render changes\r\n      if (contextWithChain.__skipAttach) {\r\n        this.#copyUnchangedElements(contextWithChain, previousContext);\r\n        this.__previousContext = contextWithChain;\r\n        return this.location;\r\n      }\r\n\r\n      this.#addAppearingContent(contextWithChain, previousContext);\r\n      const animationDone = this.#animateIfNeeded(contextWithChain);\r\n\r\n      this.#runOnAfterEnterCallbacks(contextWithChain);\r\n      this.#runOnAfterLeaveCallbacks(contextWithChain, previousContext);\r\n\r\n      await animationDone;\r\n\r\n      if (this.#isLatestRender(contextWithChain)) {\r\n        // If there is another render pass started after this one,\r\n        // the 'disappearing content' would be removed when the other\r\n        // render pass calls `this.__addAppearingContent()`\r\n        this.#removeDisappearingContent();\r\n\r\n        this.__previousContext = contextWithChain;\r\n        return this.location;\r\n      }\r\n    } catch (error: unknown) {\r\n      if (renderId === this.#lastStartedRenderId) {\r\n        if (shouldUpdateHistory) {\r\n          this.#updateBrowserHistory(this.context);\r\n        }\r\n\r\n        for (const child of this.#outlet?.children ?? []) {\r\n          child.remove();\r\n        }\r\n\r\n        this.location = createLocation(Object.assign(context, { resolver: this }));\r\n        fireRouterEvent('error', {\r\n          router: this,\r\n          error,\r\n          ...context,\r\n        });\r\n        throw error;\r\n      }\r\n    }\r\n\r\n    return this.location;\r\n  }\r\n\r\n  // `topOfTheChainContextBeforeRedirects` is a context coming from Resolver.resolve().\r\n  // It would contain a 'redirect' route or the first 'component' route that\r\n  // matched the pathname. There might be more child 'component' routes to be\r\n  // resolved and added into the chain. This method would find and add them.\r\n  // `contextBeforeRedirects` is the context containing such a child component\r\n  // route. It's only necessary when this method is called recursively (otherwise\r\n  // it's the same as the 'top of the chain' context).\r\n  //\r\n  // Apart from building the chain of child components, this method would also\r\n  // handle 'redirect' routes, call 'onBefore' callbacks and handle 'prevent'\r\n  // and 'redirect' callback results.\r\n  async #fullyResolveChain(\r\n    topOfTheChainContextBeforeRedirects: RouteContext<R, C>,\r\n    contextBeforeRedirects: RouteContext<R, C> = topOfTheChainContextBeforeRedirects,\r\n  ): Promise<RouteContext<R, C>> {\r\n    const contextAfterRedirects = await this.#findComponentContextAfterAllRedirects(contextBeforeRedirects);\r\n\r\n    const redirectsHappened = contextAfterRedirects !== contextBeforeRedirects;\r\n    const topOfTheChainContextAfterRedirects = redirectsHappened\r\n      ? contextAfterRedirects\r\n      : topOfTheChainContextBeforeRedirects;\r\n\r\n    const matchedPath = getPathnameForRouter(getMatchedPath(contextAfterRedirects.chain ?? []), this);\r\n    const isFound = matchedPath === contextAfterRedirects.pathname;\r\n\r\n    // Recursive method to try matching more child and sibling routes\r\n    const findNextContextIfAny = async (\r\n      context: RouteContext<R, C>,\r\n      parent: Route<R, C> | undefined = context.route,\r\n      prevResult?: NextResult<R, C> | null,\r\n    ): Promise<NextResult<R, C>> => {\r\n      const nextContext = await context.next(false, parent, prevResult);\r\n\r\n      if (nextContext === null || nextContext === notFoundResult) {\r\n        // Next context is not found in children, ...\r\n        if (isFound) {\r\n          // ...but original context is already fully matching - use it\r\n          return context;\r\n        } else if (parent.parent != null) {\r\n          // ...and there is no full match yet - step up to check siblings\r\n          return await findNextContextIfAny(context, parent.parent, nextContext);\r\n        }\r\n        return nextContext;\r\n      }\r\n\r\n      return nextContext;\r\n    };\r\n\r\n    const nextContext = await findNextContextIfAny(contextAfterRedirects);\r\n\r\n    if (nextContext == null || nextContext === notFoundResult) {\r\n      throw getNotFoundError<ActionValue, RouteExtension<R, C>, ContextExtension<R, C>>(\r\n        topOfTheChainContextAfterRedirects,\r\n      );\r\n    }\r\n\r\n    return nextContext !== contextAfterRedirects\r\n      ? await this.#fullyResolveChain(topOfTheChainContextAfterRedirects, nextContext)\r\n      : await this.#amendWithOnBeforeCallbacks(contextAfterRedirects);\r\n  }\r\n\r\n  async #findComponentContextAfterAllRedirects(context: RouteContext<R, C>): Promise<RouteContext<R, C>> {\r\n    const { result } = context;\r\n    if (result instanceof HTMLElement) {\r\n      renderElement(context, result as WebComponentInterface<R, C>);\r\n      return context;\r\n    } else if (result && 'redirect' in result) {\r\n      const ctx = await this.#redirect(result.redirect, context.__redirectCount, context.__renderId);\r\n      return await this.#findComponentContextAfterAllRedirects(ctx);\r\n    }\r\n\r\n    throw result instanceof Error\r\n      ? result\r\n      : new Error(\r\n          log(\r\n            `Invalid route resolution result for path \"${context.pathname}\". ` +\r\n              `Expected redirect object or HTML element, but got: \"${logValue(result)}\". ` +\r\n              `Double check the action return value for the route.`,\r\n          ),\r\n        );\r\n  }\r\n\r\n  async #amendWithOnBeforeCallbacks(contextWithFullChain: RouteContext<R, C>): Promise<RouteContext<R, C>> {\r\n    return await this.#runOnBeforeCallbacks(contextWithFullChain).then(async (amendedContext) => {\r\n      if (amendedContext === this.__previousContext || amendedContext === contextWithFullChain) {\r\n        return amendedContext;\r\n      }\r\n      return await this.#fullyResolveChain(amendedContext);\r\n    });\r\n  }\r\n\r\n  async #runOnBeforeCallbacks(newContext: RouteContext<R, C>): Promise<RouteContext<R, C>> {\r\n    const previousContext = (this.__previousContext ?? {}) as Partial<RouteContext<R, C>>;\r\n    const previousChain = previousContext.chain ?? [];\r\n    const newChain = newContext.chain ?? [];\r\n\r\n    let callbacks: Promise<ActionResult> = Promise.resolve(undefined);\r\n    const redirect = (pathname: string) => createRedirect(newContext, pathname) as unknown as RedirectResult;\r\n\r\n    newContext.__divergedChainIndex = 0;\r\n    newContext.__skipAttach = false;\r\n    if (previousChain.length) {\r\n      for (let i = 0; i < Math.min(previousChain.length, newChain.length); newContext.__divergedChainIndex++, i++) {\r\n        if (\r\n          previousChain[i].route !== newChain[i].route ||\r\n          (previousChain[i].path !== newChain[i].path && previousChain[i].element !== newChain[i].element) ||\r\n          !this.#isReusableElement(\r\n            previousChain[i].element as HTMLElement | undefined,\r\n            newChain[i].element as HTMLElement | undefined,\r\n          )\r\n        ) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Skip re-attaching and notifications if element and chain do not change\r\n      newContext.__skipAttach =\r\n        // Same route chain\r\n        newChain.length === previousChain.length &&\r\n        newContext.__divergedChainIndex === newChain.length &&\r\n        // Same element\r\n        this.#isReusableElement(newContext.result, previousContext.result);\r\n\r\n      if (newContext.__skipAttach) {\r\n        // execute onBeforeLeave for changed segment element when skipping attach\r\n        for (let i = newChain.length - 1; i >= 0; i--) {\r\n          callbacks = this.#runOnBeforeLeaveCallbacks(callbacks, newContext, { prevent }, previousChain[i]);\r\n        }\r\n        // execute onBeforeEnter for changed segment element when skipping attach\r\n        for (let i = 0; i < newChain.length; i++) {\r\n          callbacks = this.#runOnBeforeEnterCallbacks(\r\n            callbacks,\r\n            newContext,\r\n            {\r\n              prevent,\r\n              redirect,\r\n            },\r\n            newChain[i],\r\n          );\r\n          previousChain[i].element!.location = createLocation(newContext, previousChain[i].route);\r\n        }\r\n      } else {\r\n        // execute onBeforeLeave when NOT skipping attach\r\n        for (let i = previousChain.length - 1; i >= newContext.__divergedChainIndex; i--) {\r\n          callbacks = this.#runOnBeforeLeaveCallbacks(callbacks, newContext, { prevent }, previousChain[i]);\r\n        }\r\n      }\r\n    }\r\n    // execute onBeforeEnter when NOT skipping attach\r\n    if (!newContext.__skipAttach) {\r\n      for (let i = 0; i < newChain.length; i++) {\r\n        if (i < newContext.__divergedChainIndex) {\r\n          if (i < previousChain.length && previousChain[i].element) {\r\n            previousChain[i].element!.location = createLocation(newContext, previousChain[i].route);\r\n          }\r\n        } else {\r\n          callbacks = this.#runOnBeforeEnterCallbacks(\r\n            callbacks,\r\n            newContext,\r\n            {\r\n              prevent,\r\n              redirect,\r\n            },\r\n            newChain[i],\r\n          );\r\n          if (newChain[i].element) {\r\n            newChain[i].element!.location = createLocation(newContext, newChain[i].route);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return await callbacks.then(async (amendmentResult: ActionResult) => {\r\n      if (amendmentResult && isObject(amendmentResult)) {\r\n        if ('cancel' in amendmentResult && this.__previousContext) {\r\n          this.__previousContext.__renderId = newContext.__renderId;\r\n          return this.__previousContext;\r\n        }\r\n        if ('redirect' in amendmentResult) {\r\n          return await this.#redirect(amendmentResult.redirect, newContext.__redirectCount, newContext.__renderId);\r\n        }\r\n      }\r\n      return newContext;\r\n    });\r\n  }\r\n\r\n  async #runOnBeforeLeaveCallbacks(\r\n    callbacks: Promise<ActionResult>,\r\n    newContext: RouteContext<R, C>,\r\n    commands: PreventCommands,\r\n    chainElement: ChainItem<R, C>,\r\n  ): Promise<ActionResult> {\r\n    const location = createLocation(newContext);\r\n\r\n    let result: ActionResult = await callbacks;\r\n\r\n    if (this.#isLatestRender(newContext)) {\r\n      const beforeLeaveFunction = amend('onBeforeLeave', chainElement.element, location, commands, this);\r\n      result = beforeLeaveFunction(result);\r\n    }\r\n\r\n    if (!(isObject(result) && 'redirect' in result)) {\r\n      return result as ActionResult;\r\n    }\r\n  }\r\n\r\n  async #runOnBeforeEnterCallbacks(\r\n    callbacks: Promise<ActionResult>,\r\n    newContext: RouteContext<R, C>,\r\n    commands: PreventAndRedirectCommands,\r\n    chainElement: ChainItem<R, C>,\r\n  ): Promise<ActionResult> {\r\n    const location = createLocation(newContext, chainElement.route);\r\n    const result = await callbacks;\r\n\r\n    if (this.#isLatestRender(newContext)) {\r\n      const beforeEnterFunction = amend('onBeforeEnter', chainElement.element, location, commands, this);\r\n      return beforeEnterFunction(result);\r\n    }\r\n  }\r\n\r\n  #isReusableElement(element?: unknown, otherElement?: unknown): boolean {\r\n    if (element instanceof Element && otherElement instanceof Element) {\r\n      return this.#createdByRouter.has(element) && this.#createdByRouter.has(otherElement)\r\n        ? element.localName === otherElement.localName\r\n        : element === otherElement;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  #isLatestRender(context: Partial<RouteContext<R, C>>): boolean {\r\n    return context.__renderId === this.#lastStartedRenderId;\r\n  }\r\n\r\n  declare ['resolve']: (\r\n    contextOrPathname: RouteContext<R, C> | string,\r\n  ) => Promise<RouteContext<R, C> & RedirectContextInfo>;\r\n\r\n  async #redirect(\r\n    redirectData: RedirectContextInfo,\r\n    counter: number = 0,\r\n    renderId: number = 0,\r\n  ): Promise<RouteContext<R, C> & RedirectContextInfo> {\r\n    if (counter > MAX_REDIRECT_COUNT) {\r\n      throw new Error(log(`Too many redirects when rendering ${redirectData.from}`));\r\n    }\r\n\r\n    return await this.resolve({\r\n      ...(rootContext as RouteContext<R, C>),\r\n      pathname: this.urlForPath(redirectData.pathname, redirectData.params),\r\n      redirectFrom: redirectData.from,\r\n      __redirectCount: counter + 1,\r\n      __renderId: renderId,\r\n    });\r\n  }\r\n\r\n  #ensureOutlet(outlet: Element | DocumentFragment | undefined | null = this.#outlet): void {\r\n    if (!(outlet instanceof Element || outlet instanceof DocumentFragment)) {\r\n      throw new TypeError(\r\n        log(`Expected router outlet to be a valid DOM Element | DocumentFragment (but got ${outlet})`),\r\n      );\r\n    }\r\n  }\r\n\r\n  // eslint-disable-next-line @typescript-eslint/class-methods-use-this\r\n  #updateBrowserHistory({ pathname, search = '', hash = '' }: ResolveContext, replace?: boolean): void {\r\n    if (window.location.pathname !== pathname || window.location.search !== search || window.location.hash !== hash) {\r\n      const changeState = replace ? 'replaceState' : 'pushState';\r\n      window.history[changeState](null, document.title, pathname + search + hash);\r\n      window.dispatchEvent(new PopStateEvent('popstate', { state: 'vaadin-router-ignore' }));\r\n    }\r\n  }\r\n\r\n  #copyUnchangedElements(\r\n    context: RouteContext<R, C>,\r\n    previousContext?: RouteContext<R, C>,\r\n  ): Element | DocumentFragment | null | undefined {\r\n    // Find the deepest common parent between the last and the new component\r\n    // chains. Update references for the unchanged elements in the new chain\r\n    let deepestCommonParent = this.#outlet;\r\n    for (let i = 0; i < (context.__divergedChainIndex ?? 0); i++) {\r\n      const unchangedElement = previousContext?.chain?.[i].element;\r\n      if (unchangedElement) {\r\n        if (unchangedElement.parentNode === deepestCommonParent) {\r\n          (context.chain![i] as Writable<ChainItem<R, C>>).element = unchangedElement;\r\n          deepestCommonParent = unchangedElement;\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    return deepestCommonParent;\r\n  }\r\n\r\n  #addAppearingContent(context: RouteContext<R, C>, previousContext?: RouteContext<R, C>): void {\r\n    this.#ensureOutlet();\r\n\r\n    // If the previous 'entering' animation has not completed yet,\r\n    // stop it and remove that content from the DOM before adding new one.\r\n    this.#removeAppearingContent();\r\n\r\n    // Copy reusable elements from the previousContext to current\r\n    const deepestCommonParent = this.#copyUnchangedElements(context, previousContext);\r\n\r\n    // Keep two lists of DOM elements:\r\n    //  - those that should be removed once the transition animation is over\r\n    //  - and those that should remain\r\n    this.#appearingContent = [];\r\n    this.#disappearingContent = Array.from(deepestCommonParent?.children ?? []).filter(\r\n      // Only remove layout content that was added by router\r\n      (e) =>\r\n        this.#addedByRouter.has(e) &&\r\n        // Do not remove the result element to avoid flickering\r\n        e !== context.result,\r\n    );\r\n\r\n    // Add new elements (starting after the deepest common parent) to the DOM.\r\n    // That way only the components that are actually different between the two\r\n    // locations are added to the DOM (and those that are common remain in the\r\n    // DOM without first removing and then adding them again).\r\n    let parentElement = deepestCommonParent;\r\n    for (let i = context.__divergedChainIndex ?? 0; i < (context.chain?.length ?? 0); i++) {\r\n      const elementToAdd = context.chain![i].element;\r\n      if (elementToAdd) {\r\n        parentElement?.appendChild(elementToAdd);\r\n        this.#addedByRouter.add(elementToAdd);\r\n        if (parentElement === deepestCommonParent) {\r\n          this.#appearingContent.push(elementToAdd);\r\n        }\r\n        parentElement = elementToAdd;\r\n      }\r\n    }\r\n  }\r\n\r\n  #removeDisappearingContent(): void {\r\n    if (this.#disappearingContent) {\r\n      for (const element of this.#disappearingContent) {\r\n        element.remove();\r\n      }\r\n    }\r\n    this.#disappearingContent = null;\r\n    this.#appearingContent = null;\r\n  }\r\n\r\n  #removeAppearingContent(): void {\r\n    if (this.#disappearingContent && this.#appearingContent) {\r\n      for (const element of this.#appearingContent) {\r\n        element.remove();\r\n      }\r\n      this.#disappearingContent = null;\r\n      this.#appearingContent = null;\r\n    }\r\n  }\r\n\r\n  #runOnAfterLeaveCallbacks(currentContext: RouteContext<R, C>, targetContext?: RouteContext<R, C>): void {\r\n    if (!targetContext?.chain || currentContext.__divergedChainIndex == null) {\r\n      return;\r\n    }\r\n\r\n    // REVERSE iteration: from Z to A\r\n    for (let i = targetContext.chain.length - 1; i >= currentContext.__divergedChainIndex; i--) {\r\n      if (!this.#isLatestRender(currentContext)) {\r\n        break;\r\n      }\r\n      const currentComponent = targetContext.chain[i].element;\r\n      if (!currentComponent) {\r\n        continue;\r\n      }\r\n      try {\r\n        const location = createLocation(currentContext);\r\n        // eslint-disable-next-line @typescript-eslint/unbound-method\r\n        maybeCall(currentComponent.onAfterLeave, currentComponent, location, {} as EmptyCommands, this);\r\n      } finally {\r\n        if (this.#disappearingContent?.includes(currentComponent)) {\r\n          for (const child of currentComponent.children) {\r\n            child.remove();\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  #runOnAfterEnterCallbacks(currentContext: RouteContext<R, C>): void {\r\n    if (!currentContext.chain || currentContext.__divergedChainIndex == null) {\r\n      return;\r\n    }\r\n\r\n    // forward iteration: from A to Z\r\n    for (let i = currentContext.__divergedChainIndex; i < currentContext.chain.length; i++) {\r\n      if (!this.#isLatestRender(currentContext)) {\r\n        break;\r\n      }\r\n      const currentComponent = currentContext.chain[i].element;\r\n      if (currentComponent) {\r\n        const location = createLocation(currentContext, currentContext.chain[i].route);\r\n        // eslint-disable-next-line @typescript-eslint/unbound-method\r\n        maybeCall(currentComponent.onAfterEnter, currentComponent, location, {}, this);\r\n      }\r\n    }\r\n  }\r\n\r\n  async #animateIfNeeded(context: RouteContext<R, C>): Promise<RouteContext<R, C>> {\r\n    const from = this.#disappearingContent?.[0];\r\n    const to = this.#appearingContent?.[0];\r\n    const promises = [];\r\n\r\n    const { chain = [] } = context;\r\n    let config;\r\n    for (let i = chain.length - 1; i >= 0; i--) {\r\n      if (chain[i].route.animate) {\r\n        config = chain[i].route.animate;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (from && to && config) {\r\n      const leave = isObject(config) && config.leave ? config.leave : 'leaving';\r\n      const enter = isObject(config) && config.enter ? config.enter : 'entering';\r\n      promises.push(animate(from, leave));\r\n      promises.push(animate(to, enter));\r\n    }\r\n\r\n    await Promise.all(promises);\r\n\r\n    return context;\r\n  }\r\n\r\n  /**\r\n   * Subscribes this instance to navigation events on the `window`.\r\n   *\r\n   * NOTE: beware of resource leaks. For as long as a router instance is\r\n   * subscribed to navigation events, it won't be garbage collected.\r\n   */\r\n  subscribe(): void {\r\n    window.addEventListener('vaadin-router-go', this.#navigationEventHandler);\r\n  }\r\n\r\n  /**\r\n   * Removes the subscription to navigation events created in the `subscribe()`\r\n   * method.\r\n   */\r\n  unsubscribe(): void {\r\n    window.removeEventListener('vaadin-router-go', this.#navigationEventHandler);\r\n  }\r\n\r\n  #onNavigationEvent(event?: Event): void {\r\n    const { pathname, search, hash } =\r\n      event instanceof CustomEvent ? (event.detail as ResolveContext) : window.location;\r\n\r\n    if (isString(this.__normalizePathname(pathname))) {\r\n      if (event?.preventDefault) {\r\n        event.preventDefault();\r\n      }\r\n      // eslint-disable-next-line no-void\r\n      void this.render({ pathname, search, hash }, true);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Configures what triggers Router navigation events:\r\n   *  - `POPSTATE`: popstate events on the current `window`\r\n   *  - `CLICK`: click events on `<a>` links leading to the current page\r\n   *\r\n   * This method is invoked with the pre-configured values when creating a new Router instance.\r\n   * By default, both `POPSTATE` and `CLICK` are enabled. This setup is expected to cover most of the use cases.\r\n   *\r\n   * See the `router-config.js` for the default navigation triggers config. Based on it, you can\r\n   * create the own one and only import the triggers you need, instead of pulling in all the code,\r\n   * e.g. if you want to handle `click` differently.\r\n   *\r\n   * See also **Navigation Triggers** section in [Live Examples](#/classes/Router/demos/demo/index.html).\r\n   *\r\n   * @param triggers - navigation triggers\r\n   */\r\n  static setTriggers(...triggers: readonly NavigationTrigger[]): void {\r\n    setNavigationTriggers(triggers);\r\n  }\r\n\r\n  /**\r\n   * Generates a URL for the route with the given name, optionally performing\r\n   * substitution of parameters.\r\n   *\r\n   * The route is searched in all the Router instances subscribed to\r\n   * navigation events.\r\n   *\r\n   * **Note:** For child route names, only array children are considered.\r\n   * It is not possible to generate URLs using a name for routes set with\r\n   * a children function.\r\n   *\r\n   * @param name - The route name or the route\u2019s `component` name.\r\n   * @param params - Optional object with route path parameters.\r\n   * Named parameters are passed by name (`params[name] = value`), unnamed\r\n   * parameters are passed by index (`params[index] = value`).\r\n   */\r\n  urlForName(name: string, params?: Params | null): string {\r\n    if (!this.#urlForName) {\r\n      this.#urlForName = generateUrls(this, {\r\n        cacheKeyProvider(route): string | undefined {\r\n          return 'component' in route && typeof route.component === 'string'\r\n            ? (route as Readonly<{ component: string }>).component\r\n            : undefined;\r\n        },\r\n      });\r\n    }\r\n    return getPathnameForRouter(this.#urlForName(name, params ?? undefined), this);\r\n  }\r\n\r\n  /**\r\n   * Generates a URL for the given route path, optionally performing\r\n   * substitution of parameters.\r\n   *\r\n   * @param path - String route path declared in [express.js\r\n   * syntax](https://expressjs.com/en/guide/routing.html#route-paths).\r\n   * @param params - Optional object with route path parameters.\r\n   * Named parameters are passed by name (`params[name] = value`), unnamed\r\n   * parameters are passed by index (`params[index] = value`).\r\n   */\r\n  urlForPath(path: string, params?: Params | null): string {\r\n    return getPathnameForRouter(\r\n      compile(path)((params as Partial<Record<string, string | string[]>> | null) ?? undefined),\r\n      this,\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Triggers navigation to a new path. Returns a boolean without waiting until\r\n   * the navigation is complete. Returns `true` if at least one `Router`\r\n   * has handled the navigation (was subscribed and had `baseUrl` matching\r\n   * the `path` argument), otherwise returns `false`.\r\n   *\r\n   * @param path - A new in-app path string, or an URL-like object with\r\n   * `pathname` string property, and optional `search` and `hash` string\r\n   * properties.\r\n   */\r\n  static go(path: string | ResolveContext): boolean {\r\n    const { pathname, search, hash } = isString(path)\r\n      ? new URL(path, 'http://a') // some base to omit origin\r\n      : path;\r\n    return fireRouterEvent('go', { pathname, search, hash });\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["value", "_a", "result", "char", "prefix", "resolveRoute", "_a", "cache", "getRoutePath", "triggers", "nextContext"]
}
